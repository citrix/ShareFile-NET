// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//     
//	   Copyright (c) 2018 Citrix ShareFile. All rights reserved.
// </auto-generated>
// ------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using ShareFile.Api.Client;
using ShareFile.Api.Client.Extensions;
using ShareFile.Api.Client.Models;
using ShareFile.Api.Client.Requests;


namespace ShareFile.Api.Client.Entities
{
    public interface ISharesEntity : IEntityBase
    {
        
        /// <summary>
        /// Get List of Shares
        /// </summary>
        /// <remarks>
        /// Retrieve all outstanding Shares of the authenticated user
        /// </remarks>
        /// <param name="includeExpired"></param>
        /// <returns>
        /// List of Shares created by the authenticated user
        /// </returns>
        IQuery<ODataFeed<Share>> Get(bool includeExpired = true);
        
        /// <summary>
        /// Get List of Shares
        /// </summary>
        /// <remarks>
        /// Retrieve all outstanding Shares of the authenticated user
        /// </remarks>
        /// <param name="includeExpired"></param>
        /// <returns>
        /// List of Shares created by the authenticated user
        /// </returns>
        IQuery<Share> Get(Uri url);
        
        /// <summary>
        /// Get Recipients of a Share
        /// </summary>
        /// <remarks>
        /// Retrieve the list of Recipients in the share. Recipients represent the target users of the Share, containing
        /// access information, such as number of times that user downloaded files from the share. Each Recipient is
        /// identified by an Alias, which is an unique ID given to each user - allowing tracking of downloads for
        /// non-authenticated users.
        /// </remarks>
        /// <param name="url"></param>
        /// <returns>
        /// A feed of Share Aliases representing recipients of the Share
        /// </returns>
        IQuery<ODataFeed<ShareAlias>> GetRecipients(Uri url);
        
        /// <summary>
        /// Get Recipient of a Share
        /// </summary>
        /// <remarks>
        /// Retrieve a single Share Recipient identified by the alias id.
        /// </remarks>
        /// <param name="parentUrl"></param>
        /// <param name="id"></param>
        /// <returns>
        /// A Share Alias representing a single recipient of the Share
        /// </returns>
        IQuery<ShareAlias> GetRecipients(Uri parentUrl, string id);
        
        /// <summary>
        /// Create Recipient for a Share
        /// </summary>
        /// <remarks>
        /// Creates a Recipient User for a Share that requires user information
        /// </remarks>
        /// <param name="parentUrl"></param>
        /// <param name="Email"></param>
        /// <param name="FirstName"></param>
        /// <param name="LastName"></param>
        /// <param name="Company"></param>
        /// <returns>
        /// A Share Alias representing a single recipient of the Share
        /// </returns>
        IQuery<ShareAlias> CreateRecipients(Uri parentUrl, string Email = null, string FirstName = null, string LastName = null, string Company = null);
        
        /// <summary>
        /// Get Items of a Share
        /// </summary>
        /// <remarks>
        /// Retrieve the list of Items (files and folders) in the Send Share.
        /// </remarks>
        /// <param name="url"></param>
        /// <returns>
        /// A feed of Items of the Share
        /// </returns>
        IQuery<ODataFeed<Item>> GetItems(Uri url);
        
        /// <summary>
        /// Get Items of a Send Share
        /// </summary>
        /// <remarks>
        /// Retrieve a single Item in the Send Share
        /// </remarks>
        /// <param name="shareUrl"></param>
        /// <param name="itemid"></param>
        /// <returns>
        /// An item in the Share
        /// </returns>
        IQuery<Item> GetItems(Uri shareUrl, string itemid);
        
        /// <summary>
        /// Get Thumbnail of a Share Item
        /// </summary>
        /// <remarks>
        /// Retrieve a thumbnail link for the specified Item in the Share.
        /// </remarks>
        /// <param name="shareUrl"></param>
        /// <param name="itemid"></param>
        /// <param name="size"></param>
        /// <param name="redirect"></param>
        /// <returns>
        /// A 302 redirection to the Thumbnail link
        /// </returns>
        IQuery<System.IO.Stream> Thumbnail(Uri shareUrl, string itemid, int size = 75, bool redirect = false);
        
        /// <summary>
        /// Get List of Protocol Links of a Share item
        /// </summary>
        /// <param name="shareUrl"></param>
        /// <param name="itemid"></param>
        /// <param name="platform"></param>
        /// <returns>
        /// A list of protocol links depending on the input parameter 'platform', 404 (Not Found) if not supported by the item
        /// </returns>
        IQuery<ODataFeed<ItemProtocolLink>> ProtocolLinks(Uri shareUrl, string itemid, PreviewPlatform platform);
        
        /// <summary>
        /// Downloads Share Items
        /// </summary>
        /// <remarks>
        /// Downloads items from the Share. The default action will download all Items in the Share.
        /// If a Share has a single item, the download attachment name
        /// will use the item name. Otherwise, the download will contain a ZIP archive containing all
        /// files and folders in the share, named Files.zip.To download Shares that require authentication, make sure this request is authenticated. To download
        /// shares that require require user information, provide the Name, Email and Company parameters in the URI
        /// query. Anyone can download files from anonymous shares.You can also download individual Items in the Share. Use the Share(id)/Items(id)/Download action. The
        /// item ID must be a top-level item in the Share - i.e., you cannot download or address files contained inside
        /// a shared folder.
        /// </remarks>
        /// <param name="shareUrl"></param>
        /// <param name="itemId"></param>
        /// <param name="Name"></param>
        /// <param name="Email"></param>
        /// <param name="Company"></param>
        /// <param name="redirect"></param>
        /// <returns>
        /// Redirects the caller (302) to the download address for the share contents.
        /// </returns>
        IQuery<System.IO.Stream> Download(Uri shareUrl, string itemId = null, string Name = null, string Email = null, string Company = null, bool redirect = true);
        
        /// <summary>
        /// Download Items from a Share for a Recipient
        /// </summary>
        /// <example>
        /// GET https://account.sf-api.com/sf/v3/Shares(shareid)/Recipients(aliasid)/DownloadWithAlias?id=itemid
        /// GET https://account.sf-api.com/sf/v3/Shares(shareid)/Recipients(aliasid)/DownloadWithAlias(itemid)
        /// </example>
        /// <remarks>
        /// Downloads items from the Share. The default action will download all Items in the Share.
        /// If a Share has a single item, the download attachment name
        /// will use the item name. Otherwise, the download will contain a ZIP archive containing all
        /// files and folders in the share, named Files.zip.To download Shares that require user informaion ( Email, First Name, Last Name and Company), make sure
        /// to create an Recipient (alias)To download Shares that require authentication, make sure this request is authenticated.
        /// Anyone can download files from anonymous shares.You can also download individual Items in the Share. Use the Shares(id)/Recipients(aliasid)/Download action. The
        /// item ID must be a top-level item in the Share - i.e., you cannot download or address files contained inside
        /// a shared folder.
        /// </remarks>
        /// <param name="shareUrl"></param>
        /// <param name="aliasid"></param>
        /// <param name="itemId"></param>
        /// <param name="redirect"></param>
        /// <returns>
        /// Redirects the caller (302) to the download address for the share contents.
        /// </returns>
        IQuery<System.IO.Stream> DownloadWithAlias(Uri shareUrl, string aliasid, string itemId = null, bool redirect = true);
        
        /// <summary>
        /// Download Multiple Items from a Share for a Recipient
        /// </summary>
        /// <example>
        /// ["id1","id2"]
        /// </example>
        /// <remarks>
        /// Download Multiple Items from a Share for a Recipient. The download will contain a ZIP archive containing all
        /// files and folders in the share, named Files.zip.To download Shares that require user informaion ( Email, First Name, Last Name and Company), make sure
        /// to create an Recipient (alias) and pass in the alaisId.To download Shares that require authentication, make sure this request is authenticated.
        /// Anyone can download files from anonymous shares.
        /// </remarks>
        /// <param name="shareUrl"></param>
        /// <param name="aliasid"></param>
        /// <param name="ids"></param>
        /// <param name="redirect"></param>
        /// <returns>
        /// Redirects the caller (302) to the download address for the share contents.
        /// </returns>
        IQuery<System.IO.Stream> BulkDownload(Uri shareUrl, string aliasid, IEnumerable<string> ids, bool redirect = true);
        
        /// <summary>
        /// Create Share
        /// </summary>
        /// <example>
        /// {
        /// "ShareType":"Send",
        /// "Title":"Sample Send Share",
        /// "Items": [ { "Id":"itemid01" }, { "Id":"itemid02" } ],
        /// "Recipients":[ { "User": { "Id":"userid" } }, { "User": { "Email": "user@email" } } ],
        /// "ExpirationDate": "2013-07-23",
        /// "RequireLogin": false,
        /// "RequireUserInfo": false,
        /// "MaxDownloads": -1,
        /// "UsesStreamIDs": false
        /// }
        /// {
        /// "ShareType":"Request",
        /// "Title":"Sample Request Share",
        /// "Recipients":[ { "User": { "Id":"userid" } }, { "User": { "Email": "user@email" } } ],
        /// "Parent": { "Id":"folderid" },
        /// "ExpirationDate": "2013-07-23",
        /// "RequireLogin": false,
        /// "RequireUserInfo": false,
        /// "TrackUntilDate": "2013-07-23",
        /// "SendFrequency": -1,
        /// "SendInterval": -1
        /// }
        /// </example>
        /// <remarks>
        /// Creates a new Send or Request Share.
        /// Expiration date:
        /// - if not specified the default is 30 days
        /// - "9999-12-31" disables share expiration.
        /// To use stream IDs as item IDs UsesStreamIDs needs to be set to true, and all the IDs in Items need to be specified
        /// as stream IDs.
        /// View Only:
        /// View Only share can be created by either setting "IsViewOnly = true" or "share.ShareAccessRight.ShareAccessRightType = ViewOnline"
        /// If both "share.IsViewOnly = true" and "share.ShareAccessRight.AccessRightType = FullControl" are passed to this method, then the "Full Control" permission takes higher priority
        /// and disables "ViewOnly" permission on the share.
        /// Only one of the two features(ViewOnly, IRM) can be enabled at a time. If you set both "IsViewOnly = true" and "share.ShareAccessRight.ShareAccessRightType = IRM", exception will be thrown
        /// </remarks>
        /// <param name="share"></param>
        /// <param name="notify"></param>
        /// <param name="direct"></param>
        /// <returns>
        /// The new Share
        /// </returns>
        IQuery<Share> Create(Share share, bool notify = false, bool direct = false);
        
        /// <summary>
        /// Update Share
        /// </summary>
        /// <example>
        /// {
        /// "Title": "New Title",
        /// "ExpirationDate": "2013-07-23",
        /// "RequireLogin": false,
        /// "Items": [ { "Id":"itemid01" }, { "Id":"itemid02" } ],
        /// }
        /// </example>
        /// <remarks>
        /// Modifies an existing Share. If Items are specified they are added to the share by default. If appendItemsFeed is set to false, the specified Items will replace any existing ones instead.
        /// 
        /// View Only:
        /// If a share is not IRM Classified, it can be updated to ViewOnline/ViewOnly share by passing either "IsViewOnly= true" or "Share.ShareAccessRight.AccessRightType = ViewOnline"
        /// If a share is IRM Classified, then it can be updated to ViewOnline/ViewOnly share only by passing "Share.ShareAccessRight = ViewOnline". This will remove the IRMClassification on this share.
        /// Only one of the two features(ViewOnly, IRM) can be enabled at a time.
        /// 
        /// Full Control:
        /// Passing "Share.ShareAccessRight.AccessRightType = FullControl" will remove IRMClassification and ViewOnly features on the share. If you set both "IsViewOnly = true" and "share.ShareAccessRight.ShareAccessRightType = IRM", exception will be thrown
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="share"></param>
        /// <param name="appendItemsFeed"></param>
        /// <returns>
        /// The modified Share
        /// </returns>
        IQuery<Share> Update(Uri url, Share share, bool appendItemsFeed = true);
        
        /// <summary>
        /// Delete Share
        /// </summary>
        /// <remarks>
        /// Removes an existing Share
        /// </remarks>
        /// <param name="url"></param>
        IQuery Delete(Uri url);
        
        /// <summary>
        /// Create Share Alias
        /// </summary>
        /// <remarks>
        /// Creates a share alias for the specified share ID and user email. If a user with the given email address does not
        /// exist it is created first.
        /// For shares requiring login an activation email is sent to the created user. If 'notify' is enabled, the user activation is
        /// included in the share notification email.
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="email"></param>
        /// <param name="notify"></param>
        /// <returns>
        /// Share with the AliasID property set to the created alias ID
        /// </returns>
        IQuery<Share> CreateAlias(Uri url, string email, bool notify = false);
        
        /// <summary>
        /// Deliver Send a File Email
        /// </summary>
        /// <example>
        /// {
        /// "Items":["itemId1", "itemId2"],
        /// "Emails":["email@sharefile.com", "email2@sharefile.com"],
        /// "Subject": "Email Subject",
        /// "Body": "Email Message",
        /// "CcSender": false,
        /// "NotifyOnDownload": true,
        /// "RequireLogin": false,
        /// "MaxDownloads": 30,
        /// "ExpirationDays": -1
        /// }
        /// </example>
        /// <remarks>
        /// Sends an Email to the specified list of addresses, containing a link to the specified Items.
        /// The default number of expiration days is 30. Setting it to -1 disables share expiration. Note that the
        /// Emails and Items parameters expect an array of strings, rather than nested JSON objects.
        /// </remarks>
        /// <param name="parameters"></param>
        /// <returns>
        /// Share object
        /// </returns>
        IQuery<Share> CreateSend(ShareSendParams parameters);
        
        /// <summary>
        /// Deliver Request a File Email
        /// </summary>
        /// <example>
        /// {
        /// "FolderId":"folderId",
        /// "Emails":["email@sharefile.com", "email2@sharefile.com"],
        /// "Subject": "Email Subject",
        /// "Body": "Email Message",
        /// "CcSender": false,
        /// "NotifyOnUpload": true,
        /// "RequireLogin": false,
        /// "ExpirationDays": -1
        /// }
        /// </example>
        /// <remarks>
        /// Sends an Email to the specified list of addresses, containing a link to upload to the specified folder.
        /// The default number of expiration days is 30. Setting it to -1 disables share expiration. Note that the
        /// Emails parameter expectd an array of strings, rather than nested JSON objects.
        /// 
        /// View Only:
        /// View Only share can be created by either setting "IsViewOnly = true" or "share.ShareAccessRight.ShareAccessRightType = ViewOnline"
        /// If both "share.IsViewOnly = true" and "share.ShareAccessRight.AccessRightType = FullControl" are passed to this method, then the "Full Control" permission takes higher priority
        /// and disables "ViewOnly" permission on the share.
        /// Only one of the two features(ViewOnly, IRM) can be enabled at a time. If you set both "IsViewOnly = true" and "share.ShareAccessRight.ShareAccessRightType = IRM", exception will be thrown
        /// </remarks>
        /// <param name="parameters"></param>
        /// <returns>
        /// Share Object
        /// </returns>
        IQuery<Share> CreateRequest(ShareRequestParams parameters);
        
        /// <summary>
        /// Re-deliver an Existing Share Link
        /// </summary>
        /// <example>
        /// {
        /// "Recipients":["email@sharefile.com", "groupId"],
        /// "Subject": "Email Subject",
        /// "Body": "Email Message",
        /// "CcSender": false,
        /// "NotifyOnUse": true,
        /// "ShareId": "shareId"
        /// }
        /// </example>
        /// <remarks>
        /// Resends an Email to the specified list of addresses, containing a link to a Send or Request Share
        /// </remarks>
        /// <param name="parameters"></param>
        /// <returns>
        /// The updated Share
        /// </returns>
        IQuery<Share> Resend(ShareResendParams parameters);
        
        /// <summary>
        /// Upload File to Request Share
        /// </summary>
        /// <example>
        /// POST https://account.sf-api.com/sf/v3/Shares(id)/Upload2
        /// {
        /// "Method":"Method",
        /// "Raw": false,
        /// "FileName":"FileName",
        /// "FileLength": 123
        /// }
        /// </example>
        /// <remarks>
        /// Prepares the links for uploading files to the target Share.
        /// This method returns an Upload Specification object. The fields are
        /// populated based on the upload method, provider, and resume parameters passed to the
        /// upload call.
        /// The Method determines how the URLs must be called.
        /// 
        /// Standard uploads use a single HTTP POST message to the ChunkUri address provided in
        /// the response. All other fields will be empty. Standard uploads do not support Resume.
        /// 
        /// Streamed uploads use multiple HTTP POST calls to the ChunkUri address. The client must
        /// append the parameters index, offset and hash to the end of the ChunkUri address. Index
        /// is a sequential number representing the data block (zero-based); Offset represents the
        /// byte offset for the block; and hash contains the MD5 hash of the block. The last HTTP
        /// POST must also contain finish=true parameter.
        /// 
        /// Threaded uploads use multiple HTTP POST calls to ChunkUri, and can have a number of
        /// threads issuing blocks in parallel. Clients must append index, offset and hash to
        /// the end of ChunkUri, as explained in Streamed. After all chunks were sent, the client
        /// must call the FinishUri provided in this spec.
        /// 
        /// For all uploaders, the contents of the POST Body can either be "raw", if the "Raw" parameter
        /// was provided to the Uploader, or use MIME multi-part form encoding otherwise. Raw uploads
        /// simply put the block content in the POST body - Content-Length specifies the size. Multi-part
        /// form encoding has to pass the File as a Form parameter named "File1".
        /// 
        /// For streamed and threaded, if Resume options were provided to the Upload call, then the
        /// fields IsResume, ResumeIndex, ResumeOffset and ResumeFileHash MAY be populated. If they are,
        /// it indicates that the server has identified a partial upload with that specification, and is
        /// ready to resume on the provided parameters. The clients can then verify the ResumeFileHash to
        /// ensure the file has not been modified; and continue issuing ChunkUri calls from the ResumeIndex
        /// ResumeOffset parameters. If the client decides to restart, it should simply ignore the resume
        /// parameters and send the blocks from Index 0.
        /// 
        /// For all uploaders: the result code for the HTTP POST calls to Chunk and Finish Uri can either
        /// be a 401 - indicating authentication is required; 4xx/5xx indicating some kind of error; or
        /// 200 with a Content Body of format 'ERROR:message'. Successful calls will return either a 200
        /// response with no Body, or with Body of format 'OK'.
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="method"></param>
        /// <param name="raw"></param>
        /// <param name="fileName"></param>
        /// <param name="fileSize"></param>
        /// <param name="batchId"></param>
        /// <param name="batchLast"></param>
        /// <param name="canResume"></param>
        /// <param name="startOver"></param>
        /// <param name="unzip"></param>
        /// <param name="tool"></param>
        /// <param name="overwrite"></param>
        /// <param name="title"></param>
        /// <param name="details"></param>
        /// <param name="isSend"></param>
        /// <param name="sendGuid"></param>
        /// <param name="opid"></param>
        /// <param name="threadCount"></param>
        /// <param name="responseFormat"></param>
        /// <param name="notify"></param>
        /// <returns>
        /// an Upload Specification element, containing the links for uploading, and the parameters for resume.
        /// The caller must know the protocol for sending the prepare, chunk and finish URLs returned in the spec; as well as
        /// negotiate the resume upload.
        /// </returns>
        IQuery<UploadSpecification> Upload(Uri url, UploadMethod method = UploadMethod.Standard, bool raw = false, string fileName = null, long fileSize = 0, string batchId = null, bool batchLast = false, bool canResume = false, bool startOver = false, bool unzip = false, string tool = "apiv3", bool overwrite = false, string title = null, string details = null, bool isSend = false, string sendGuid = null, string opid = null, int threadCount = 4, string responseFormat = "json", bool notify = false, DateTime? clientCreatedDateUTC = null, DateTime? clientModifiedDateUTC = null, int? expirationDays = null);
        IQuery<UploadSpecification> Upload2(Uri url, UploadRequestParams uploadParams, int? expirationDays = null);
        
        /// <summary>
        /// Get Redirection endpoint Information
        /// </summary>
        /// <remarks>
        /// Returns the redirection endpoint for this Share.
        /// </remarks>
        /// <param name="url"></param>
        /// <returns>
        /// The Redirection endpoint Information
        /// </returns>
        IQuery<Redirection> GetRedirection(Uri url);
        
        /// <summary>
        /// Get Inbox for Recipient
        /// </summary>
        /// <remarks>
        /// Retrieve all outstanding Shares in the inbox.
        /// </remarks>
        /// <param name="userId"></param>
        /// <returns>
        /// List of Shares created by the authenticated user
        /// </returns>
        IQuery<ODataFeed<Share>> GetInbox(string userId = null, ShareType type = ShareType.Both, bool archived = false);
        
        /// <summary>
        /// Get Sent Message Content by Share
        /// </summary>
        /// <remarks>
        /// Returns sent message content. By default the message is returned as a plain string. If asJson is true, the message
        /// string is wrapped in a Json object with a single "Message" property.
        /// </remarks>
        /// <param name="shareUrl"></param>
        /// <param name="aliasId"></param>
        /// <returns>
        /// Sent Message Content
        /// </returns>
        IQuery<System.IO.Stream> Message(Uri shareUrl, string aliasId, bool asJson = false);
    }

    public class SharesEntity : EntityBase, ISharesEntity
    {
        public SharesEntity (IShareFileClient client)
            : base (client, "Shares")
        { }
        
        
        /// <summary>
        /// Get List of Shares
        /// </summary>
        /// <remarks>
        /// Retrieve all outstanding Shares of the authenticated user
        /// </remarks>
        /// <param name="includeExpired"></param>
        /// <returns>
        /// List of Shares created by the authenticated user
        /// </returns>
        public IQuery<ODataFeed<Share>> Get(bool includeExpired = true)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<ODataFeed<Share>>(Client);
            sfApiQuery.From("Shares");
            sfApiQuery.QueryString("includeExpired", includeExpired);
            sfApiQuery.HttpMethod = "GET";	
            return sfApiQuery;
        }
        
        /// <summary>
        /// Get List of Shares
        /// </summary>
        /// <remarks>
        /// Retrieve all outstanding Shares of the authenticated user
        /// </remarks>
        /// <param name="includeExpired"></param>
        /// <returns>
        /// List of Shares created by the authenticated user
        /// </returns>
        public IQuery<Share> Get(Uri url)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Share>(Client);
            sfApiQuery.Uri(url);
            sfApiQuery.HttpMethod = "GET";	
            return sfApiQuery;
        }
        
        /// <summary>
        /// Get Recipients of a Share
        /// </summary>
        /// <remarks>
        /// Retrieve the list of Recipients in the share. Recipients represent the target users of the Share, containing
        /// access information, such as number of times that user downloaded files from the share. Each Recipient is
        /// identified by an Alias, which is an unique ID given to each user - allowing tracking of downloads for
        /// non-authenticated users.
        /// </remarks>
        /// <param name="url"></param>
        /// <returns>
        /// A feed of Share Aliases representing recipients of the Share
        /// </returns>
        public IQuery<ODataFeed<ShareAlias>> GetRecipients(Uri url)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<ODataFeed<ShareAlias>>(Client);
            sfApiQuery.Action("Recipients");
            sfApiQuery.Uri(url);
            sfApiQuery.HttpMethod = "GET";	
            return sfApiQuery;
        }
        
        /// <summary>
        /// Get Recipient of a Share
        /// </summary>
        /// <remarks>
        /// Retrieve a single Share Recipient identified by the alias id.
        /// </remarks>
        /// <param name="parentUrl"></param>
        /// <param name="id"></param>
        /// <returns>
        /// A Share Alias representing a single recipient of the Share
        /// </returns>
        public IQuery<ShareAlias> GetRecipients(Uri parentUrl, string id)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<ShareAlias>(Client);
            sfApiQuery.Action("Recipients");
            sfApiQuery.Uri(parentUrl);
            sfApiQuery.ActionIds(id);
            sfApiQuery.HttpMethod = "GET";	
            return sfApiQuery;
        }
        
        /// <summary>
        /// Create Recipient for a Share
        /// </summary>
        /// <remarks>
        /// Creates a Recipient User for a Share that requires user information
        /// </remarks>
        /// <param name="parentUrl"></param>
        /// <param name="Email"></param>
        /// <param name="FirstName"></param>
        /// <param name="LastName"></param>
        /// <param name="Company"></param>
        /// <returns>
        /// A Share Alias representing a single recipient of the Share
        /// </returns>
        public IQuery<ShareAlias> CreateRecipients(Uri parentUrl, string Email = null, string FirstName = null, string LastName = null, string Company = null)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<ShareAlias>(Client);
            sfApiQuery.Action("Recipients");
            sfApiQuery.Uri(parentUrl);
            sfApiQuery.QueryString("Email", Email);
            sfApiQuery.QueryString("FirstName", FirstName);
            sfApiQuery.QueryString("LastName", LastName);
            sfApiQuery.QueryString("Company", Company);
            sfApiQuery.HttpMethod = "POST";	
            return sfApiQuery;
        }
        
        /// <summary>
        /// Get Items of a Share
        /// </summary>
        /// <remarks>
        /// Retrieve the list of Items (files and folders) in the Send Share.
        /// </remarks>
        /// <param name="url"></param>
        /// <returns>
        /// A feed of Items of the Share
        /// </returns>
        public IQuery<ODataFeed<Item>> GetItems(Uri url)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<ODataFeed<Item>>(Client);
            sfApiQuery.Action("Items");
            sfApiQuery.Uri(url);
            sfApiQuery.HttpMethod = "GET";	
            return sfApiQuery;
        }
        
        /// <summary>
        /// Get Items of a Send Share
        /// </summary>
        /// <remarks>
        /// Retrieve a single Item in the Send Share
        /// </remarks>
        /// <param name="shareUrl"></param>
        /// <param name="itemid"></param>
        /// <returns>
        /// An item in the Share
        /// </returns>
        public IQuery<Item> GetItems(Uri shareUrl, string itemid)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Item>(Client);
            sfApiQuery.Action("Items");
            sfApiQuery.Uri(shareUrl);
            sfApiQuery.ActionIds(itemid);
            sfApiQuery.HttpMethod = "GET";	
            return sfApiQuery;
        }
        
        /// <summary>
        /// Get Thumbnail of a Share Item
        /// </summary>
        /// <remarks>
        /// Retrieve a thumbnail link for the specified Item in the Share.
        /// </remarks>
        /// <param name="shareUrl"></param>
        /// <param name="itemid"></param>
        /// <param name="size"></param>
        /// <param name="redirect"></param>
        /// <returns>
        /// A 302 redirection to the Thumbnail link
        /// </returns>
        public IQuery<System.IO.Stream> Thumbnail(Uri shareUrl, string itemid, int size = 75, bool redirect = false)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<System.IO.Stream>(Client);
            sfApiQuery.Action("Items");
            sfApiQuery.Uri(shareUrl);
            sfApiQuery.ActionIds(itemid);
            sfApiQuery.SubAction("Thumbnail");
            sfApiQuery.QueryString("size", size);
            sfApiQuery.QueryString("redirect", redirect);
            sfApiQuery.HttpMethod = "GET";	
            return sfApiQuery;
        }
        
        /// <summary>
        /// Get List of Protocol Links of a Share item
        /// </summary>
        /// <param name="shareUrl"></param>
        /// <param name="itemid"></param>
        /// <param name="platform"></param>
        /// <returns>
        /// A list of protocol links depending on the input parameter 'platform', 404 (Not Found) if not supported by the item
        /// </returns>
        public IQuery<ODataFeed<ItemProtocolLink>> ProtocolLinks(Uri shareUrl, string itemid, PreviewPlatform platform)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<ODataFeed<ItemProtocolLink>>(Client);
            sfApiQuery.Action("Items");
            sfApiQuery.Uri(shareUrl);
            sfApiQuery.ActionIds(itemid);
            sfApiQuery.SubAction("ProtocolLinks", platform);
            sfApiQuery.HttpMethod = "GET";	
            return sfApiQuery;
        }
        
        /// <summary>
        /// Downloads Share Items
        /// </summary>
        /// <remarks>
        /// Downloads items from the Share. The default action will download all Items in the Share.
        /// If a Share has a single item, the download attachment name
        /// will use the item name. Otherwise, the download will contain a ZIP archive containing all
        /// files and folders in the share, named Files.zip.To download Shares that require authentication, make sure this request is authenticated. To download
        /// shares that require require user information, provide the Name, Email and Company parameters in the URI
        /// query. Anyone can download files from anonymous shares.You can also download individual Items in the Share. Use the Share(id)/Items(id)/Download action. The
        /// item ID must be a top-level item in the Share - i.e., you cannot download or address files contained inside
        /// a shared folder.
        /// </remarks>
        /// <param name="shareUrl"></param>
        /// <param name="itemId"></param>
        /// <param name="Name"></param>
        /// <param name="Email"></param>
        /// <param name="Company"></param>
        /// <param name="redirect"></param>
        /// <returns>
        /// Redirects the caller (302) to the download address for the share contents.
        /// </returns>
        public IQuery<System.IO.Stream> Download(Uri shareUrl, string itemId = null, string Name = null, string Email = null, string Company = null, bool redirect = true)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<System.IO.Stream>(Client);
            sfApiQuery.Action("Download");
            sfApiQuery.Uri(shareUrl);
            sfApiQuery.QueryString("id", itemId);
            sfApiQuery.QueryString("Name", Name);
            sfApiQuery.QueryString("Email", Email);
            sfApiQuery.QueryString("Company", Company);
            sfApiQuery.QueryString("redirect", redirect);
            sfApiQuery.HttpMethod = "GET";	
            return sfApiQuery;
        }
        
        /// <summary>
        /// Download Items from a Share for a Recipient
        /// </summary>
        /// <example>
        /// GET https://account.sf-api.com/sf/v3/Shares(shareid)/Recipients(aliasid)/DownloadWithAlias?id=itemid
        /// GET https://account.sf-api.com/sf/v3/Shares(shareid)/Recipients(aliasid)/DownloadWithAlias(itemid)
        /// </example>
        /// <remarks>
        /// Downloads items from the Share. The default action will download all Items in the Share.
        /// If a Share has a single item, the download attachment name
        /// will use the item name. Otherwise, the download will contain a ZIP archive containing all
        /// files and folders in the share, named Files.zip.To download Shares that require user informaion ( Email, First Name, Last Name and Company), make sure
        /// to create an Recipient (alias)To download Shares that require authentication, make sure this request is authenticated.
        /// Anyone can download files from anonymous shares.You can also download individual Items in the Share. Use the Shares(id)/Recipients(aliasid)/Download action. The
        /// item ID must be a top-level item in the Share - i.e., you cannot download or address files contained inside
        /// a shared folder.
        /// </remarks>
        /// <param name="shareUrl"></param>
        /// <param name="aliasid"></param>
        /// <param name="itemId"></param>
        /// <param name="redirect"></param>
        /// <returns>
        /// Redirects the caller (302) to the download address for the share contents.
        /// </returns>
        public IQuery<System.IO.Stream> DownloadWithAlias(Uri shareUrl, string aliasid, string itemId = null, bool redirect = true)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<System.IO.Stream>(Client);
            sfApiQuery.Action("Recipients");
            sfApiQuery.Uri(shareUrl);
            sfApiQuery.ActionIds(aliasid);
            sfApiQuery.SubAction("DownloadWithAlias");
            sfApiQuery.QueryString("id", itemId);
            sfApiQuery.QueryString("redirect", redirect);
            sfApiQuery.HttpMethod = "GET";	
            return sfApiQuery;
        }
        
        /// <summary>
        /// Download Multiple Items from a Share for a Recipient
        /// </summary>
        /// <example>
        /// ["id1","id2"]
        /// </example>
        /// <remarks>
        /// Download Multiple Items from a Share for a Recipient. The download will contain a ZIP archive containing all
        /// files and folders in the share, named Files.zip.To download Shares that require user informaion ( Email, First Name, Last Name and Company), make sure
        /// to create an Recipient (alias) and pass in the alaisId.To download Shares that require authentication, make sure this request is authenticated.
        /// Anyone can download files from anonymous shares.
        /// </remarks>
        /// <param name="shareUrl"></param>
        /// <param name="aliasid"></param>
        /// <param name="ids"></param>
        /// <param name="redirect"></param>
        /// <returns>
        /// Redirects the caller (302) to the download address for the share contents.
        /// </returns>
        public IQuery<System.IO.Stream> BulkDownload(Uri shareUrl, string aliasid, IEnumerable<string> ids, bool redirect = true)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<System.IO.Stream>(Client);
            sfApiQuery.Action("Recipients");
            sfApiQuery.Uri(shareUrl);
            sfApiQuery.ActionIds(aliasid);
            sfApiQuery.SubAction("BulkDownload");
            sfApiQuery.QueryString("redirect", redirect);
            sfApiQuery.Body = ids;
            sfApiQuery.HttpMethod = "POST";	
            return sfApiQuery;
        }
        
        /// <summary>
        /// Create Share
        /// </summary>
        /// <example>
        /// {
        /// "ShareType":"Send",
        /// "Title":"Sample Send Share",
        /// "Items": [ { "Id":"itemid01" }, { "Id":"itemid02" } ],
        /// "Recipients":[ { "User": { "Id":"userid" } }, { "User": { "Email": "user@email" } } ],
        /// "ExpirationDate": "2013-07-23",
        /// "RequireLogin": false,
        /// "RequireUserInfo": false,
        /// "MaxDownloads": -1,
        /// "UsesStreamIDs": false
        /// }
        /// {
        /// "ShareType":"Request",
        /// "Title":"Sample Request Share",
        /// "Recipients":[ { "User": { "Id":"userid" } }, { "User": { "Email": "user@email" } } ],
        /// "Parent": { "Id":"folderid" },
        /// "ExpirationDate": "2013-07-23",
        /// "RequireLogin": false,
        /// "RequireUserInfo": false,
        /// "TrackUntilDate": "2013-07-23",
        /// "SendFrequency": -1,
        /// "SendInterval": -1
        /// }
        /// </example>
        /// <remarks>
        /// Creates a new Send or Request Share.
        /// Expiration date:
        /// - if not specified the default is 30 days
        /// - "9999-12-31" disables share expiration.
        /// To use stream IDs as item IDs UsesStreamIDs needs to be set to true, and all the IDs in Items need to be specified
        /// as stream IDs.
        /// View Only:
        /// View Only share can be created by either setting "IsViewOnly = true" or "share.ShareAccessRight.ShareAccessRightType = ViewOnline"
        /// If both "share.IsViewOnly = true" and "share.ShareAccessRight.AccessRightType = FullControl" are passed to this method, then the "Full Control" permission takes higher priority
        /// and disables "ViewOnly" permission on the share.
        /// Only one of the two features(ViewOnly, IRM) can be enabled at a time. If you set both "IsViewOnly = true" and "share.ShareAccessRight.ShareAccessRightType = IRM", exception will be thrown
        /// </remarks>
        /// <param name="share"></param>
        /// <param name="notify"></param>
        /// <param name="direct"></param>
        /// <returns>
        /// The new Share
        /// </returns>
        public IQuery<Share> Create(Share share, bool notify = false, bool direct = false)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Share>(Client);
            sfApiQuery.From("Shares");
            sfApiQuery.QueryString("notify", notify);
            sfApiQuery.QueryString("direct", direct);
            sfApiQuery.Body = share;
            sfApiQuery.HttpMethod = "POST";	
            return sfApiQuery;
        }
        
        /// <summary>
        /// Update Share
        /// </summary>
        /// <example>
        /// {
        /// "Title": "New Title",
        /// "ExpirationDate": "2013-07-23",
        /// "RequireLogin": false,
        /// "Items": [ { "Id":"itemid01" }, { "Id":"itemid02" } ],
        /// }
        /// </example>
        /// <remarks>
        /// Modifies an existing Share. If Items are specified they are added to the share by default. If appendItemsFeed is set to false, the specified Items will replace any existing ones instead.
        /// 
        /// View Only:
        /// If a share is not IRM Classified, it can be updated to ViewOnline/ViewOnly share by passing either "IsViewOnly= true" or "Share.ShareAccessRight.AccessRightType = ViewOnline"
        /// If a share is IRM Classified, then it can be updated to ViewOnline/ViewOnly share only by passing "Share.ShareAccessRight = ViewOnline". This will remove the IRMClassification on this share.
        /// Only one of the two features(ViewOnly, IRM) can be enabled at a time.
        /// 
        /// Full Control:
        /// Passing "Share.ShareAccessRight.AccessRightType = FullControl" will remove IRMClassification and ViewOnly features on the share. If you set both "IsViewOnly = true" and "share.ShareAccessRight.ShareAccessRightType = IRM", exception will be thrown
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="share"></param>
        /// <param name="appendItemsFeed"></param>
        /// <returns>
        /// The modified Share
        /// </returns>
        public IQuery<Share> Update(Uri url, Share share, bool appendItemsFeed = true)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Share>(Client);
            sfApiQuery.Uri(url);
            sfApiQuery.QueryString("appendItemsFeed", appendItemsFeed);
            sfApiQuery.Body = share;
            sfApiQuery.HttpMethod = "PATCH";	
            return sfApiQuery;
        }
        
        /// <summary>
        /// Delete Share
        /// </summary>
        /// <remarks>
        /// Removes an existing Share
        /// </remarks>
        /// <param name="url"></param>
        public IQuery Delete(Uri url)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query(Client);
            sfApiQuery.Uri(url);
            sfApiQuery.HttpMethod = "DELETE";	
            return sfApiQuery;
        }
        
        /// <summary>
        /// Create Share Alias
        /// </summary>
        /// <remarks>
        /// Creates a share alias for the specified share ID and user email. If a user with the given email address does not
        /// exist it is created first.
        /// For shares requiring login an activation email is sent to the created user. If 'notify' is enabled, the user activation is
        /// included in the share notification email.
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="email"></param>
        /// <param name="notify"></param>
        /// <returns>
        /// Share with the AliasID property set to the created alias ID
        /// </returns>
        public IQuery<Share> CreateAlias(Uri url, string email, bool notify = false)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Share>(Client);
            sfApiQuery.Action("Alias");
            sfApiQuery.Uri(url);
            sfApiQuery.QueryString("email", email);
            sfApiQuery.QueryString("notify", notify);
            sfApiQuery.HttpMethod = "POST";	
            return sfApiQuery;
        }
        
        /// <summary>
        /// Deliver Send a File Email
        /// </summary>
        /// <example>
        /// {
        /// "Items":["itemId1", "itemId2"],
        /// "Emails":["email@sharefile.com", "email2@sharefile.com"],
        /// "Subject": "Email Subject",
        /// "Body": "Email Message",
        /// "CcSender": false,
        /// "NotifyOnDownload": true,
        /// "RequireLogin": false,
        /// "MaxDownloads": 30,
        /// "ExpirationDays": -1
        /// }
        /// </example>
        /// <remarks>
        /// Sends an Email to the specified list of addresses, containing a link to the specified Items.
        /// The default number of expiration days is 30. Setting it to -1 disables share expiration. Note that the
        /// Emails and Items parameters expect an array of strings, rather than nested JSON objects.
        /// </remarks>
        /// <param name="parameters"></param>
        /// <returns>
        /// Share object
        /// </returns>
        public IQuery<Share> CreateSend(ShareSendParams parameters)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Share>(Client);
            sfApiQuery.From("Shares");
            sfApiQuery.Action("Send");
            sfApiQuery.Body = parameters;
            sfApiQuery.HttpMethod = "POST";	
            return sfApiQuery;
        }
        
        /// <summary>
        /// Deliver Request a File Email
        /// </summary>
        /// <example>
        /// {
        /// "FolderId":"folderId",
        /// "Emails":["email@sharefile.com", "email2@sharefile.com"],
        /// "Subject": "Email Subject",
        /// "Body": "Email Message",
        /// "CcSender": false,
        /// "NotifyOnUpload": true,
        /// "RequireLogin": false,
        /// "ExpirationDays": -1
        /// }
        /// </example>
        /// <remarks>
        /// Sends an Email to the specified list of addresses, containing a link to upload to the specified folder.
        /// The default number of expiration days is 30. Setting it to -1 disables share expiration. Note that the
        /// Emails parameter expectd an array of strings, rather than nested JSON objects.
        /// 
        /// View Only:
        /// View Only share can be created by either setting "IsViewOnly = true" or "share.ShareAccessRight.ShareAccessRightType = ViewOnline"
        /// If both "share.IsViewOnly = true" and "share.ShareAccessRight.AccessRightType = FullControl" are passed to this method, then the "Full Control" permission takes higher priority
        /// and disables "ViewOnly" permission on the share.
        /// Only one of the two features(ViewOnly, IRM) can be enabled at a time. If you set both "IsViewOnly = true" and "share.ShareAccessRight.ShareAccessRightType = IRM", exception will be thrown
        /// </remarks>
        /// <param name="parameters"></param>
        /// <returns>
        /// Share Object
        /// </returns>
        public IQuery<Share> CreateRequest(ShareRequestParams parameters)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Share>(Client);
            sfApiQuery.From("Shares");
            sfApiQuery.Action("Request");
            sfApiQuery.Body = parameters;
            sfApiQuery.HttpMethod = "POST";	
            return sfApiQuery;
        }
        
        /// <summary>
        /// Re-deliver an Existing Share Link
        /// </summary>
        /// <example>
        /// {
        /// "Recipients":["email@sharefile.com", "groupId"],
        /// "Subject": "Email Subject",
        /// "Body": "Email Message",
        /// "CcSender": false,
        /// "NotifyOnUse": true,
        /// "ShareId": "shareId"
        /// }
        /// </example>
        /// <remarks>
        /// Resends an Email to the specified list of addresses, containing a link to a Send or Request Share
        /// </remarks>
        /// <param name="parameters"></param>
        /// <returns>
        /// The updated Share
        /// </returns>
        public IQuery<Share> Resend(ShareResendParams parameters)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Share>(Client);
            sfApiQuery.From("Shares");
            sfApiQuery.Action("Resend");
            sfApiQuery.Body = parameters;
            sfApiQuery.HttpMethod = "POST";	
            return sfApiQuery;
        }
        
        /// <summary>
        /// Upload File to Request Share
        /// </summary>
        /// <example>
        /// POST https://account.sf-api.com/sf/v3/Shares(id)/Upload2
        /// {
        /// "Method":"Method",
        /// "Raw": false,
        /// "FileName":"FileName",
        /// "FileLength": 123
        /// }
        /// </example>
        /// <remarks>
        /// Prepares the links for uploading files to the target Share.
        /// This method returns an Upload Specification object. The fields are
        /// populated based on the upload method, provider, and resume parameters passed to the
        /// upload call.
        /// The Method determines how the URLs must be called.
        /// 
        /// Standard uploads use a single HTTP POST message to the ChunkUri address provided in
        /// the response. All other fields will be empty. Standard uploads do not support Resume.
        /// 
        /// Streamed uploads use multiple HTTP POST calls to the ChunkUri address. The client must
        /// append the parameters index, offset and hash to the end of the ChunkUri address. Index
        /// is a sequential number representing the data block (zero-based); Offset represents the
        /// byte offset for the block; and hash contains the MD5 hash of the block. The last HTTP
        /// POST must also contain finish=true parameter.
        /// 
        /// Threaded uploads use multiple HTTP POST calls to ChunkUri, and can have a number of
        /// threads issuing blocks in parallel. Clients must append index, offset and hash to
        /// the end of ChunkUri, as explained in Streamed. After all chunks were sent, the client
        /// must call the FinishUri provided in this spec.
        /// 
        /// For all uploaders, the contents of the POST Body can either be "raw", if the "Raw" parameter
        /// was provided to the Uploader, or use MIME multi-part form encoding otherwise. Raw uploads
        /// simply put the block content in the POST body - Content-Length specifies the size. Multi-part
        /// form encoding has to pass the File as a Form parameter named "File1".
        /// 
        /// For streamed and threaded, if Resume options were provided to the Upload call, then the
        /// fields IsResume, ResumeIndex, ResumeOffset and ResumeFileHash MAY be populated. If they are,
        /// it indicates that the server has identified a partial upload with that specification, and is
        /// ready to resume on the provided parameters. The clients can then verify the ResumeFileHash to
        /// ensure the file has not been modified; and continue issuing ChunkUri calls from the ResumeIndex
        /// ResumeOffset parameters. If the client decides to restart, it should simply ignore the resume
        /// parameters and send the blocks from Index 0.
        /// 
        /// For all uploaders: the result code for the HTTP POST calls to Chunk and Finish Uri can either
        /// be a 401 - indicating authentication is required; 4xx/5xx indicating some kind of error; or
        /// 200 with a Content Body of format 'ERROR:message'. Successful calls will return either a 200
        /// response with no Body, or with Body of format 'OK'.
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="method"></param>
        /// <param name="raw"></param>
        /// <param name="fileName"></param>
        /// <param name="fileSize"></param>
        /// <param name="batchId"></param>
        /// <param name="batchLast"></param>
        /// <param name="canResume"></param>
        /// <param name="startOver"></param>
        /// <param name="unzip"></param>
        /// <param name="tool"></param>
        /// <param name="overwrite"></param>
        /// <param name="title"></param>
        /// <param name="details"></param>
        /// <param name="isSend"></param>
        /// <param name="sendGuid"></param>
        /// <param name="opid"></param>
        /// <param name="threadCount"></param>
        /// <param name="responseFormat"></param>
        /// <param name="notify"></param>
        /// <returns>
        /// an Upload Specification element, containing the links for uploading, and the parameters for resume.
        /// The caller must know the protocol for sending the prepare, chunk and finish URLs returned in the spec; as well as
        /// negotiate the resume upload.
        /// </returns>
        public IQuery<UploadSpecification> Upload(Uri url, UploadMethod method = UploadMethod.Standard, bool raw = false, string fileName = null, long fileSize = 0, string batchId = null, bool batchLast = false, bool canResume = false, bool startOver = false, bool unzip = false, string tool = "apiv3", bool overwrite = false, string title = null, string details = null, bool isSend = false, string sendGuid = null, string opid = null, int threadCount = 4, string responseFormat = "json", bool notify = false, DateTime? clientCreatedDateUTC = null, DateTime? clientModifiedDateUTC = null, int? expirationDays = null)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<UploadSpecification>(Client);
            sfApiQuery.Action("Upload");
            sfApiQuery.Uri(url);
            sfApiQuery.QueryString("method", method);
            sfApiQuery.QueryString("raw", raw);
            sfApiQuery.QueryString("fileName", fileName);
            sfApiQuery.QueryString("fileSize", fileSize);
            sfApiQuery.QueryString("batchId", batchId);
            sfApiQuery.QueryString("batchLast", batchLast);
            sfApiQuery.QueryString("canResume", canResume);
            sfApiQuery.QueryString("startOver", startOver);
            sfApiQuery.QueryString("unzip", unzip);
            sfApiQuery.QueryString("tool", tool);
            sfApiQuery.QueryString("overwrite", overwrite);
            sfApiQuery.QueryString("title", title);
            sfApiQuery.QueryString("details", details);
            sfApiQuery.QueryString("isSend", isSend);
            sfApiQuery.QueryString("sendGuid", sendGuid);
            sfApiQuery.QueryString("opid", opid);
            sfApiQuery.QueryString("threadCount", threadCount);
            sfApiQuery.QueryString("responseFormat", responseFormat);
            sfApiQuery.QueryString("notify", notify);
            sfApiQuery.QueryString("clientCreatedDateUTC", clientCreatedDateUTC);
            sfApiQuery.QueryString("clientModifiedDateUTC", clientModifiedDateUTC);
            sfApiQuery.QueryString("expirationDays", expirationDays);
            sfApiQuery.HttpMethod = "POST";	
            return sfApiQuery;
        }
        public IQuery<UploadSpecification> Upload2(Uri url, UploadRequestParams uploadParams, int? expirationDays = null)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<UploadSpecification>(Client);
            sfApiQuery.Action("Upload2");
            sfApiQuery.Uri(url);
            sfApiQuery.QueryString("expirationDays", expirationDays);
            sfApiQuery.Body = uploadParams;
            sfApiQuery.HttpMethod = "POST";	
            return sfApiQuery;
        }
        
        /// <summary>
        /// Get Redirection endpoint Information
        /// </summary>
        /// <remarks>
        /// Returns the redirection endpoint for this Share.
        /// </remarks>
        /// <param name="url"></param>
        /// <returns>
        /// The Redirection endpoint Information
        /// </returns>
        public IQuery<Redirection> GetRedirection(Uri url)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Redirection>(Client);
            sfApiQuery.Action("Redirection");
            sfApiQuery.Uri(url);
            sfApiQuery.HttpMethod = "GET";	
            return sfApiQuery;
        }
        
        /// <summary>
        /// Get Inbox for Recipient
        /// </summary>
        /// <remarks>
        /// Retrieve all outstanding Shares in the inbox.
        /// </remarks>
        /// <param name="userId"></param>
        /// <returns>
        /// List of Shares created by the authenticated user
        /// </returns>
        public IQuery<ODataFeed<Share>> GetInbox(string userId = null, ShareType type = ShareType.Both, bool archived = false)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<ODataFeed<Share>>(Client);
            sfApiQuery.From("Shares");
            sfApiQuery.Action("Inbox");
            sfApiQuery.ActionIds(userId);
            sfApiQuery.QueryString("type", type);
            sfApiQuery.QueryString("archived", archived);
            sfApiQuery.HttpMethod = "GET";	
            return sfApiQuery;
        }
        
        /// <summary>
        /// Get Sent Message Content by Share
        /// </summary>
        /// <remarks>
        /// Returns sent message content. By default the message is returned as a plain string. If asJson is true, the message
        /// string is wrapped in a Json object with a single "Message" property.
        /// </remarks>
        /// <param name="shareUrl"></param>
        /// <param name="aliasId"></param>
        /// <returns>
        /// Sent Message Content
        /// </returns>
        public IQuery<System.IO.Stream> Message(Uri shareUrl, string aliasId, bool asJson = false)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<System.IO.Stream>(Client);
            sfApiQuery.Action("Recipients");
            sfApiQuery.Uri(shareUrl);
            sfApiQuery.ActionIds(aliasId);
            sfApiQuery.SubAction("Message");
            sfApiQuery.QueryString("asJson", asJson);
            sfApiQuery.HttpMethod = "GET";	
            return sfApiQuery;
        }
    }
}
