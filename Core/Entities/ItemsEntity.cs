// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//     
//	   Copyright (c) 2015 Citrix ShareFile. All rights reserved.
// </auto-generated>
// ------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.IO;
using ShareFile.Api.Models;
using ShareFile.Api.Client;
using ShareFile.Api.Client.Requests;
using ShareFile.Api.Client.Extensions;

namespace ShareFile.Api.Client.Entities
{
    public interface IItemsEntity : IEntityBase
    {
        
        /// <summary>
        /// Get HomeFolder for Current User
        /// </summary>
        /// <remarks>
        /// Returns home folder for current user.
        /// Note that home folders are not available for client users, or if the account doesn't have the "My Files & Folders" feature enabled.
        /// </remarks>
        /// <returns>
        /// home folder for current user
        /// </returns>
        IQuery<Item> Get();
        
        /// <summary>
        /// Get Item by ID
        /// </summary>
        /// <remarks>
        /// Returns a single Item.
        /// Special Id's:home, favorites, allshared, connectors, box, top. home - Return home folder.
        /// favorites - Return parent favorite item; use .../Items(favorites)/Children to get the favorite folders.
        /// allshared - Return parent Shared Folders item; use .../Items(allshared)/Children to get the shared folders.
        /// connectors - Return parent Connectors item; use .../Items(connectors)/Children to get indiviual connectors.
        /// box - Return the FileBox folder. top - Returns the Top item; use .../Items(top)/Children to get the home, favorites, and shared folders as well as the connectors
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="includeDeleted"></param>
        /// <returns>
        /// a single Item
        /// </returns>
        IQuery<Item> Get(Uri url, bool includeDeleted = false);
        
        /// <summary>
        /// Get TreeView
        /// </summary>
        /// <remarks>
        /// Retrieves a folder list structure tailored for TreeView navigation - used by clients
        /// to create folder trees for specific operations.
        /// This operation will enforce a specific $select and $expand operators. You can provide
        /// additional $expand, for example Children, which is not added by default. The $select
        /// operator will apply to the expanded objects as well. You can also specify additional
        /// $select elements.
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="treeMode"></param>
        /// <param name="sourceId"></param>
        /// <param name="canCreateRootFolder"></param>
        /// <param name="fileBox"></param>
        /// <returns>
        /// A tree root element.
        /// </returns>
        IQuery<Item> Get(Uri url, TreeMode treeMode, string sourceId, bool canCreateRootFolder = false, bool fileBox = false);
        
        /// <summary>
        /// Get Symbolic Links of a Connector Group
        /// </summary>
        /// <remarks>
        /// Retrieves the Symbolic Links of the provided Connector Group type. Connector Groups define
        /// classes of external data connectors - such as SharePoint, Network Shares. Symbolic Links
        /// represent a single Connector point to such classes - for example, a single SharePoint site,
        /// or a network share drive.
        /// </remarks>
        /// <param name="parentUrl"></param>
        /// <returns>
        /// The list of Symbolic Links associated with the given connector group.
        /// </returns>
        IQuery<ODataFeed<Item>> GetChildrenByConnectorGroup(Uri parentUrl);
        
        /// <summary>
        /// Get Stream
        /// </summary>
        /// <remarks>
        /// Retrieves the versions of a given Stream. The ID parameter must be a StreamID, otherwise an empty list is returned.
        /// StreamID is a property of all Items, representing the "Stream", ie., the collection of all versions of a file. In
        /// contrast, an Item ID represents a single version of a file.
        /// For example, when users upload or modify an existing file, a new Item
        /// is created with the same StreamID. All default Item enumerations return only the latest version of a given stream.
        /// Use this method to retrieve previous versions of a given stream.
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="includeDeleted"></param>
        IQuery<ODataFeed<Item>> Stream(Uri url, bool includeDeleted = false);
        
        /// <summary>
        /// Get Item by Path
        /// </summary>
        /// <remarks>
        /// Retrieves an item from its path. The path is of format /foldername/foldername/filename
        /// This call may redirect the client to another API provider, if the path
        /// contains a symbolic link.
        /// </remarks>
        /// <param name="path"></param>
        /// <returns>
        /// An item identified by a path
        /// </returns>
        IQuery<Item> ByPath(string path);
        
        /// <summary>
        /// Get Item by relative Path from ID
        /// </summary>
        /// <remarks>
        /// Retrieves an item from its path, relative to the provided ID.
        /// The path is of format /foldername/foldername/filename
        /// This call may redirect the client to another API provider, if the path
        /// contains a symbolic link.
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="path"></param>
        /// <returns>
        /// An item identified by a path
        /// </returns>
        IQuery<Item> ByPath(Uri url, string path);
        
        /// <summary>
        /// Get Parent Item
        /// </summary>
        /// <remarks>
        /// Retrieves the Parent navigation property of a single Item.
        /// </remarks>
        /// <param name="url"></param>
        /// <returns>
        /// the Parent Item of the give object ID.
        /// </returns>
        IQuery<Item> GetParent(Uri url);
        
        /// <summary>
        /// Get Children
        /// </summary>
        /// <remarks>
        /// Handler for the Children navigation property of a given Item.
        /// A 302 redirection is returned if the folder is a SymbolicLink. The redirection
        /// will enumerate the children of the remote connector
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="includeDeleted"></param>
        /// <returns>
        /// the list of children under the given object ID
        /// </returns>
        IQuery<ODataFeed<Item>> GetChildren(Uri url, bool includeDeleted = false);
        
        /// <summary>
        /// Get Folder Access Info
        /// </summary>
        /// <remarks>
        /// Returns the effective Access Controls for the current authenticated user for the
        /// selected folder - i.e., the resulting set of Access Controls for the Item/User context.This operation applies to Folders only, will return an error for other Item types.
        /// </remarks>
        /// <param name="url"></param>
        /// <returns>
        /// The Folder Access Control Information
        /// </returns>
        IQuery<ItemInfo> GetInfo(Uri url);
        
        /// <summary>
        /// Download Item Content
        /// </summary>
        /// <remarks>
        /// Initiate the download operation for an item. It will return 302 redirection to the
        /// actual download link. For Folders, the download link will retrieve a ZIP archive
        /// with the contents of the Folder.
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="redirect"></param>
        /// <returns>
        /// the download link for the provided item content.
        /// </returns>
        IQuery<Stream> Download(Uri url, bool redirect = true);
        
        /// <summary>
        /// Download Multiple Items
        /// </summary>
        /// <example>
        /// ["id1","id2",...]
        /// </example>
        /// <remarks>
        /// Initiate the download operation for items. It will return 302 redirection to the
        /// actual download link.
        /// </remarks>
        /// <param name="parentUrl"></param>
        /// <param name="ids"></param>
        /// <param name="redirect"></param>
        /// <returns>
        /// the download link for the provided item content.
        /// </returns>
        IQuery<Stream> BulkDownload(Uri parentUrl, IEnumerable<string> ids, bool redirect = true);
        
        /// <summary>
        /// Create Folder
        /// </summary>
        /// <example>
        /// {
        /// "Name":"Folder Name",
        /// "Description":"Description",
        /// "Zone":{ "Id":"z014766e-8e96-4615-86aa-57132a69843c" }
        /// }
        /// </example>
        /// <remarks>
        /// Creates a new Folder.
        /// The POST body must contain the serialized object.
        /// For top-level folders, use Items/Folder.
        /// The Zone object may only be provided for top-level folders. The Zone object must
        /// contain a zone ID.
        /// </remarks>
        /// <param name="parentUrl"></param>
        /// <param name="folder"></param>
        /// <param name="overwrite"></param>
        /// <param name="passthrough"></param>
        /// <returns>
        /// the new Folder
        /// </returns>
        IQuery<Folder> CreateFolder(Uri parentUrl, Folder folder, bool overwrite = false, bool passthrough = false);
        
        /// <summary>
        /// Create Note
        /// </summary>
        /// <example>
        /// {
        /// "Name":"Note Name",
        /// "Description":"Description"
        /// }
        /// </example>
        /// <remarks>
        /// Creates a new Note.
        /// </remarks>
        /// <param name="parentUrl"></param>
        /// <param name="note"></param>
        /// <returns>
        /// the new Note
        /// </returns>
        IQuery<Note> CreateNote(Uri parentUrl, Note note);
        
        /// <summary>
        /// Create Link
        /// </summary>
        /// <example>
        /// {
        /// "Name":"Link Name",
        /// "Description":"Description",
        /// "Uri":"https://server/path"
        /// }
        /// </example>
        /// <remarks>
        /// Creates a new Link
        /// </remarks>
        /// <param name="parentUrl"></param>
        /// <param name="link"></param>
        /// <returns>
        /// the new Link
        /// </returns>
        IQuery<Link> CreateLink(Uri parentUrl, Link link);
        
        /// <summary>
        /// Create SymbolicLink
        /// </summary>
        /// <example>
        /// {
        /// "Name":"RemoteFileName",
        /// "Description":"Description",
        /// "Zone":{ "Id":"z014766e-8e96-4615-86aa-57132a69843c" },
        /// "ConnectorGroup": { "Id":"1" }
        /// }
        /// </example>
        /// <remarks>
        /// Creates a Symbolic Link
        /// The body must contain either a "Link" parameter with a fully qualified URI; or use
        /// FileName + Zone to have sharefile.com attempt to convert the Connector path to an
        /// URI using a call to the Zone - using ShareFile Hash authentication mode. For active
        /// clients, it's recommended to make the convertion call to the Zone directly, using
        /// Items/ByPath=name, retriving the resulting URL, and calling this method with the
        /// Link parameter.SymbolicLinks must be created as top-level folders - i.e., this call requires
        /// the parent to be the Item(accountid) element.Zone defines the location of the SymbolicLink target - for example, for
        /// Network Shares connectors, the SymbolicLink will point to the StorageZone Controller
        /// that will serve the file browsing requests.The ConnectorGroup parameter indicates the kind of symbolic link - e.g., Network
        /// Share, or SharePoint.
        /// </remarks>
        /// <param name="parentUrl"></param>
        /// <param name="symlink"></param>
        /// <param name="overwrite"></param>
        /// <returns>
        /// the new SymbolicLink
        /// </returns>
        IQuery<SymbolicLink> CreateSymbolicLink(Uri parentUrl, SymbolicLink symlink, bool overwrite = false);
        
        /// <summary>
        /// Creates SymbolicLink
        /// </summary>
        /// <example>
        /// {
        /// "Name":"RemoteFileName",
        /// "Description":"Description",
        /// "Link":"https://server/provider/version/Items(id)",
        /// "Zone":{ "Id":"z014766e-8e96-4615-86aa-57132a69843c" },
        /// "ConnectorGroup": { "Id":"1" }
        /// }
        /// </example>
        /// <param name="url"></param>
        /// <param name="symlink"></param>
        /// <param name="overwrite"></param>
        /// <returns>
        /// the new SymbolicLink
        /// </returns>
        IQuery<SymbolicLink> CreateChildrenByConnectorGroup(Uri url, SymbolicLink symlink, bool overwrite = false);
        
        /// <summary>
        /// Update Item
        /// </summary>
        /// <example>
        /// {
        /// "Name":"Name",
        /// "FileName":"FileName",
        /// "Description":"Description",
        /// "ExpirationDate": "date",
        /// "Parent": { "Id": "parentid" },
        /// "Zone": { "Id": "zoneid" }
        /// }
        /// </example>
        /// <remarks>
        /// Updates an Item object. Please note that for a Folder, the Name and FileName properties must be consistent.
        /// If a new Name is provided, the FileName will also be updated with the new name, and viceversa.
        /// If both Name and FileName are provided, FileName is disregarded and Name will be used to update both properties.
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="item"></param>
        /// <param name="forceSync"></param>
        /// <returns>
        /// A modified Item object. If the item Zone or Parent Zone is modified, then this
        /// method will return an Asynchronous operation record instead. Note: the parameters listed in the
        /// body of the request are the only parameters that can be updated through this call.
        /// </returns>
        IQuery<Item> Update(Uri url, Item item, string batchid = null, long batchSizeInBytes = 0, bool forceSync = false, bool scheduleAsync = true, bool resolveFolderNameConflict = false);
        
        /// <summary>
        /// Update Link
        /// </summary>
        /// <example>
        /// {
        /// "Name":"Name",
        /// "Uri":"https://server/path",
        /// "Description":"Description",
        /// "Parent": { "Id": "parentid" },
        /// }
        /// </example>
        /// <remarks>
        /// Updates a Link object
        /// </remarks>
        /// <param name="id"></param>
        /// <param name="link"></param>
        /// <param name="notify"></param>
        /// <returns>
        /// A modified Link object
        /// </returns>
        IQuery<Link> UpdateLink(string id, Link link, bool notify = false);
        
        /// <summary>
        /// Update Note
        /// </summary>
        /// <example>
        /// {
        /// "Name":"Name",
        /// "Description":"Description",
        /// "Parent": { "Id": "parentid" },
        /// }
        /// </example>
        /// <remarks>
        /// Updates a Note object
        /// </remarks>
        /// <param name="id"></param>
        /// <param name="note"></param>
        /// <param name="notify"></param>
        /// <returns>
        /// The modified Note object
        /// </returns>
        IQuery<Note> UpdateNote(string id, Note note, bool notify = false);
        
        /// <summary>
        /// Update SymbolicLink
        /// </summary>
        /// <example>
        /// {
        /// "Name":"Name",
        /// "Description":"Description",
        /// "Link": "https://server/path"
        /// }
        /// </example>
        /// <remarks>
        /// Updates a Symbolic Link object
        /// </remarks>
        /// <param name="id"></param>
        /// <param name="symlink"></param>
        /// <returns>
        /// The modified SymbolicLink object
        /// </returns>
        IQuery<SymbolicLink> UpdateSymbolicLink(string id, SymbolicLink symlink);
        
        /// <summary>
        /// Delete Item
        /// </summary>
        /// <remarks>
        /// Removes an item
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="singleversion"></param>
        /// <param name="forceSync"></param>
        IQuery Delete(Uri url, bool singleversion = false, bool forceSync = false);
        
        /// <summary>
        /// Delete Multiple Items
        /// </summary>
        /// <example>
        /// ["id1","id2",...]
        /// </example>
        /// <remarks>
        /// All items in bulk delete must be children of the same parent, identified in the URI
        /// </remarks>
        /// <param name="id"></param>
        /// <param name="body"></param>
        /// <param name="forceSync"></param>
        /// <param name="deletePermanently"></param>
        IQuery BulkDelete(Uri url, IEnumerable<string> ids, bool forceSync = false, bool deletePermanently = false);
        
        /// <summary>
        /// Get Thumbnail
        /// </summary>
        /// <remarks>
        /// Retrieve a thumbnail link from the specified Item.
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="size"></param>
        /// <param name="redirect"></param>
        /// <returns>
        /// A 302 redirection to the Thumbnail link
        /// </returns>
        IQuery<Stream> GetThumbnail(Uri url, int size = 75, bool redirect = false);
        
        /// <summary>
        /// Get Breadcrumbs
        /// </summary>
        /// <remarks>
        /// Retrieves the path from an item from the root. The return list is a Feed of Items, with the top-level
        /// folder at the first position. If this item is in a Connection path, the breadcrumbs may contain URL
        /// reference back to the parent account - and the Item in the feed will contain just the URL reference.
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="path"></param>
        /// <returns>
        /// A feed containing the path of folders from the specified root to the item, in order
        /// </returns>
        IQuery<ODataFeed<Item>> GetBreadcrumbs(Uri url, string path = null);
        
        /// <summary>
        /// Copy Item
        /// </summary>
        /// <remarks>
        /// Copies an item to a new target Folder. If the target folder is in another zone, the operation will
        /// return an AsyncOperation record instead. Clients may query the /AsyncOperation Entity to determine
        /// operation progress and result.
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="targetid"></param>
        /// <param name="overwrite"></param>
        /// <returns>
        /// the modified source object
        /// </returns>
        IQuery<Item> Copy(Uri url, string targetid, bool overwrite = false);
        
        /// <summary>
        /// Upload File
        /// </summary>
        /// <example>
        /// POST https://account.sf-api.com/sf/v3/Items(id)/Upload2
        /// {
        /// "Method":"Method",
        /// "Raw": false,
        /// "FileName":"FileName"
        /// "FileLength": length
        /// }
        /// </example>
        /// <remarks>
        /// Prepares the links for uploading files to the target Folder.
        /// This method returns an Upload Specification object. The fields are
        /// populated based on the upload method, provider, and resume parameters passed to the
        /// upload call.
        /// The Method determines how the URLs must be called.
        /// 
        /// There are two different URL's to upload: /sf/v3/Items(id)/Upload? accepts the upload parameters
        /// through a query URL string, while /sf/v3/Items(id)/Upload2 does it through the HTTP POST message body.
        /// If using 'Upload2', the parameters must be capitalized.
        /// 
        /// Standard uploads use a single HTTP POST message to the ChunkUri address provided in
        /// the response. All other fields will be empty. Standard uploads do not support Resume.
        /// 
        /// Streamed uploads use multiple HTTP POST calls to the ChunkUri address. The client must
        /// append the parameters index, offset and hash to the end of the ChunkUri address. Index
        /// is a sequential number representing the data block (zero-based); Offset represents the
        /// byte offset for the block; and hash contains the MD5 hash of the block. The last HTTP
        /// POST must also contain finish=true parameter.
        /// 
        /// Threaded uploads use multiple HTTP POST calls to ChunkUri, and can have a number of
        /// threads issuing blocks in parallel. Clients must append index, offset and hash to
        /// the end of ChunkUri, as explained in Streamed. After all chunks were sent, the client
        /// must call the FinishUri provided in this spec.
        /// 
        /// If using the Threaded Uploader, you can attach the argument fmt=json to each ChunkUri
        /// to indicate you wish to retrieve the Item ID of the file after the upload is completed.
        /// 
        /// For all uploaders, the contents of the POST Body can either be "raw", if the "Raw" parameter
        /// was provided to the Uploader, or use MIME multi-part form encoding otherwise. Raw uploads
        /// simply put the block content in the POST body - Content-Length specifies the size. Multi-part
        /// form encoding has to pass the File as a Form parameter named "File1".
        /// 
        /// For streamed and threaded, if Resume options were provided to the Upload call, then the
        /// fields IsResume, ResumeIndex, ResumeOffset and ResumeFileHash MAY be populated. If they are,
        /// it indicates that the server has identified a partial upload with that specification, and is
        /// ready to resume on the provided parameters. The clients can then verify the ResumeFileHash to
        /// ensure the file has not been modified; and continue issuing ChunkUri calls from the ResumeIndex
        /// ResumeOffset parameters. If the client decides to restart, it should simply ignore the resume
        /// parameters and send the blocks from Index 0.
        /// 
        /// For all uploaders: the result code for the HTTP POST calls to Chunk and Finish Uri can either
        /// be a 401 - indicating authentication is required; 4xx/5xx indicating some kind of error; or
        /// 200 with a Content Body of format 'ERROR:message'. Successful calls will return either a 200
        /// response with no Body, or with Body of format 'OK'.
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="method"></param>
        /// <param name="raw"></param>
        /// <param name="fileName"></param>
        /// <param name="fileSize"></param>
        /// <param name="batchId"></param>
        /// <param name="batchLast"></param>
        /// <param name="canResume"></param>
        /// <param name="startOver"></param>
        /// <param name="unzip"></param>
        /// <param name="tool"></param>
        /// <param name="overwrite"></param>
        /// <param name="title"></param>
        /// <param name="details"></param>
        /// <param name="isSend"></param>
        /// <param name="sendGuid"></param>
        /// <param name="opid"></param>
        /// <param name="threadCount"></param>
        /// <param name="responseFormat"></param>
        /// <param name="notify"></param>
        /// <param name="clientCreatedDateUTC"></param>
        /// <param name="clientModifiedDateUTC"></param>
        /// <returns>
        /// an Upload Specification element, containing the links for uploading, and the parameters for resume.
        /// The caller must know the protocol for sending the prepare, chunk and finish URLs returned in the spec; as well as
        /// negotiate the resume upload.
        /// </returns>
        IQuery<UploadSpecification> Upload(Uri url, UploadMethod method = UploadMethod.Standard, bool raw = false, string fileName = null, long fileSize = 0, string batchId = null, bool batchLast = false, bool canResume = false, bool startOver = false, bool unzip = false, string tool = "apiv3", bool overwrite = false, string title = null, string details = null, bool isSend = false, string sendGuid = null, string opid = null, int threadCount = 4, string responseFormat = "json", bool notify = false, DateTime? clientCreatedDateUTC = null, DateTime? clientModifiedDateUTC = null, int? expirationDays = null);
        IQuery<UploadSpecification> Upload2(Uri url, UploadRequestParams uploadParams, int? expirationDays = null);
        
        /// <summary>
        /// Unlock File
        /// </summary>
        /// <remarks>
        /// Unlock a locked file.
        /// This operation is only implemented in Sharepoint providers (/sp)
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="message"></param>
        IQuery CheckIn(Uri url, string message = null);
        IQuery CheckOut(Uri url);
        IQuery DiscardCheckOut(Uri url);
        
        /// <summary>
        /// Search
        /// </summary>
        /// <remarks>
        /// Search for Items matching the criteria of the query parameter
        /// </remarks>
        /// <param name="query"></param>
        /// <param name="maxResults"></param>
        /// <param name="skip"></param>
        /// <param name="homeFolderOnly"></param>
        /// <returns>
        /// SearchResults
        /// </returns>
        IQuery<SearchResults> Search(string query, int maxResults = 50, int skip = 0, bool homeFolderOnly = false);
        
        /// <summary>
        /// Advanced Simple Search
        /// </summary>
        /// <example>
        /// {
        /// "Query":{
        /// "ItemType":"",
        /// "ParentID":"",
        /// "CreatorID":"",
        /// "SearchQuery":"",
        /// "CreateStartDate":"",
        /// "CreateEndDate":"",
        /// "ItemNameOnly":false
        /// },
        /// "Paging":{
        /// "PageNumber":1, (Deprecated)
        /// "PageSize":10, (Deprecated)
        /// "Count": 50
        /// "Skip": 0
        /// },
        /// "Sort":{
        /// "SortBy":"",
        /// "Ascending":false,
        /// },
        /// "TimeoutInSeconds":10
        /// }
        /// </example>
        /// <remarks>
        /// Search for Items matching the criteria of the query parameter
        /// </remarks>
        /// <param name="simpleSearchQuery"></param>
        /// <returns>
        /// AdvancedSearchResults
        /// </returns>
        IQuery<AdvancedSearchResults> AdvancedSimpleSearch(SimpleSearchQuery simpleSearchQuery);
        
        /// <summary>
        /// Advanced Search
        /// </summary>
        /// <example>
        /// {
        /// "Query":{
        /// "ItemTypes":["type1", "type2", ...],
        /// "ParentID":["id1", "id2", ...],
        /// "CreatorID":["id1", "id2", ...],
        /// "SearchQuery":"",
        /// "CreateStartDate":"",
        /// "CreateEndDate":"",
        /// "ItemNameOnly":false
        /// },
        /// "Paging":{
        /// "PageNumber":1, (deprecated)
        /// "PageSize":10, (deprecated)
        /// "Count":50, (default value)
        /// "Skip":0, (default value)
        /// },
        /// "Sort":{
        /// "SortBy":"",
        /// "Ascending":false,
        /// },
        /// "TimeoutInSeconds":10
        /// }
        /// </example>
        /// <remarks>
        /// Search for Items matching the criteria of the query parameter
        /// </remarks>
        /// <param name="searchQuery"></param>
        /// <returns>
        /// AdvancedSearchResults
        /// </returns>
        IQuery<AdvancedSearchResults> AdvancedSearch(SearchQuery searchQuery);
        
        /// <summary>
        /// Get Web Preview Link
        /// </summary>
        /// <remarks>
        /// Redirects the caller to the Web Edit application for the selected item.
        /// </remarks>
        /// <param name="url"></param>
        /// <returns>
        /// A redirection message to the Web Edit app for this item. It returns 404 (Not Found)
        /// if the Web Preview app doesn't support the file type.
        /// </returns>
        IQuery<Redirection> WebView(Uri url);
        
        /// <summary>
        /// Get List of Item Protocol Links
        /// </summary>
        /// <param name="url"></param>
        /// <param name="platform"></param>
        /// <returns>
        /// A list of protocol links depending on the input parameter 'platform', 404 (Not Found) if not supported by the item
        /// </returns>
        IQuery<ODataFeed<ItemProtocolLink>> GetProtocolLinks(Uri url, PreviewPlatform platform);
        
        /// <summary>
        /// Get Redirection endpoint Information
        /// </summary>
        /// <remarks>
        /// Returns the redirection endpoint for this Item.This operation applies to Folders and SymbolicLinks only, will return an error for other Item types.
        /// </remarks>
        /// <param name="url"></param>
        /// <returns>
        /// The Redirection endpoint Information
        /// </returns>
        IQuery<Redirection> GetRedirection(Uri url);
        
        /// <summary>
        /// Get a collection of recoverable/deleted items in a folder
        /// </summary>
        /// <param name="url"></param>
        IQuery<ODataFeed<Item>> GetDeletedChildren(Uri url, string id);
        IQuery<ODataFeed<Item>> GetUserDeletedItems(string userid = null, string zone = null);
        
        /// <summary>
        /// Restore expired items to their original locations
        /// </summary>
        /// <param name="ids"></param>
        IQuery BulkRestore(IEnumerable<string> ids);
        
        /// <summary>
        /// Permanently delete multiple items
        /// </summary>
        /// <param name="itemIds"></param>
        /// <param name="ids"></param>
        IQuery BulkDeletePermanently(IEnumerable<string> ids);
    }

    public class ItemsEntity : EntityBase, IItemsEntity
    {
        public ItemsEntity (IShareFileClient client)
            : base (client, "Items")
        { }
        
        
        /// <summary>
        /// Get HomeFolder for Current User
        /// </summary>
        /// <remarks>
        /// Returns home folder for current user.
        /// Note that home folders are not available for client users, or if the account doesn't have the "My Files & Folders" feature enabled.
        /// </remarks>
        /// <returns>
        /// home folder for current user
        /// </returns>
        public IQuery<Item> Get()
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Item>(Client);
		    sfApiQuery.From("Items");
            sfApiQuery.HttpMethod = "GET";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Get Item by ID
        /// </summary>
        /// <remarks>
        /// Returns a single Item.
        /// Special Id's:home, favorites, allshared, connectors, box, top. home - Return home folder.
        /// favorites - Return parent favorite item; use .../Items(favorites)/Children to get the favorite folders.
        /// allshared - Return parent Shared Folders item; use .../Items(allshared)/Children to get the shared folders.
        /// connectors - Return parent Connectors item; use .../Items(connectors)/Children to get indiviual connectors.
        /// box - Return the FileBox folder. top - Returns the Top item; use .../Items(top)/Children to get the home, favorites, and shared folders as well as the connectors
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="includeDeleted"></param>
        /// <returns>
        /// a single Item
        /// </returns>
        public IQuery<Item> Get(Uri url, bool includeDeleted = false)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Item>(Client);
            sfApiQuery.Uri(url);
            sfApiQuery.QueryString("includeDeleted", includeDeleted);
            sfApiQuery.HttpMethod = "GET";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Get TreeView
        /// </summary>
        /// <remarks>
        /// Retrieves a folder list structure tailored for TreeView navigation - used by clients
        /// to create folder trees for specific operations.
        /// This operation will enforce a specific $select and $expand operators. You can provide
        /// additional $expand, for example Children, which is not added by default. The $select
        /// operator will apply to the expanded objects as well. You can also specify additional
        /// $select elements.
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="treeMode"></param>
        /// <param name="sourceId"></param>
        /// <param name="canCreateRootFolder"></param>
        /// <param name="fileBox"></param>
        /// <returns>
        /// A tree root element.
        /// </returns>
        public IQuery<Item> Get(Uri url, TreeMode treeMode, string sourceId, bool canCreateRootFolder = false, bool fileBox = false)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Item>(Client);
            sfApiQuery.Uri(url);
            sfApiQuery.QueryString("treeMode", treeMode);
            sfApiQuery.QueryString("sourceId", sourceId);
            sfApiQuery.QueryString("canCreateRootFolder", canCreateRootFolder);
            sfApiQuery.QueryString("fileBox", fileBox);
            sfApiQuery.HttpMethod = "GET";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Get Symbolic Links of a Connector Group
        /// </summary>
        /// <remarks>
        /// Retrieves the Symbolic Links of the provided Connector Group type. Connector Groups define
        /// classes of external data connectors - such as SharePoint, Network Shares. Symbolic Links
        /// represent a single Connector point to such classes - for example, a single SharePoint site,
        /// or a network share drive.
        /// </remarks>
        /// <param name="parentUrl"></param>
        /// <returns>
        /// The list of Symbolic Links associated with the given connector group.
        /// </returns>
        public IQuery<ODataFeed<Item>> GetChildrenByConnectorGroup(Uri parentUrl)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<ODataFeed<Item>>(Client);
		    sfApiQuery.Action("Children");
            sfApiQuery.Uri(parentUrl);
            sfApiQuery.HttpMethod = "GET";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Get Stream
        /// </summary>
        /// <remarks>
        /// Retrieves the versions of a given Stream. The ID parameter must be a StreamID, otherwise an empty list is returned.
        /// StreamID is a property of all Items, representing the "Stream", ie., the collection of all versions of a file. In
        /// contrast, an Item ID represents a single version of a file.
        /// For example, when users upload or modify an existing file, a new Item
        /// is created with the same StreamID. All default Item enumerations return only the latest version of a given stream.
        /// Use this method to retrieve previous versions of a given stream.
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="includeDeleted"></param>
        public IQuery<ODataFeed<Item>> Stream(Uri url, bool includeDeleted = false)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<ODataFeed<Item>>(Client);
		    sfApiQuery.Action("Stream");
            sfApiQuery.Uri(url);
            sfApiQuery.QueryString("includeDeleted", includeDeleted);
            sfApiQuery.HttpMethod = "GET";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Get Item by Path
        /// </summary>
        /// <remarks>
        /// Retrieves an item from its path. The path is of format /foldername/foldername/filename
        /// This call may redirect the client to another API provider, if the path
        /// contains a symbolic link.
        /// </remarks>
        /// <param name="path"></param>
        /// <returns>
        /// An item identified by a path
        /// </returns>
        public IQuery<Item> ByPath(string path)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Item>(Client);
		    sfApiQuery.From("Items");
		    sfApiQuery.Action("ByPath");
            sfApiQuery.QueryString("path", path);
            sfApiQuery.HttpMethod = "GET";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Get Item by relative Path from ID
        /// </summary>
        /// <remarks>
        /// Retrieves an item from its path, relative to the provided ID.
        /// The path is of format /foldername/foldername/filename
        /// This call may redirect the client to another API provider, if the path
        /// contains a symbolic link.
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="path"></param>
        /// <returns>
        /// An item identified by a path
        /// </returns>
        public IQuery<Item> ByPath(Uri url, string path)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Item>(Client);
		    sfApiQuery.Action("ByPath");
            sfApiQuery.Uri(url);
            sfApiQuery.QueryString("path", path);
            sfApiQuery.HttpMethod = "GET";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Get Parent Item
        /// </summary>
        /// <remarks>
        /// Retrieves the Parent navigation property of a single Item.
        /// </remarks>
        /// <param name="url"></param>
        /// <returns>
        /// the Parent Item of the give object ID.
        /// </returns>
        public IQuery<Item> GetParent(Uri url)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Item>(Client);
		    sfApiQuery.Action("Parent");
            sfApiQuery.Uri(url);
            sfApiQuery.HttpMethod = "GET";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Get Children
        /// </summary>
        /// <remarks>
        /// Handler for the Children navigation property of a given Item.
        /// A 302 redirection is returned if the folder is a SymbolicLink. The redirection
        /// will enumerate the children of the remote connector
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="includeDeleted"></param>
        /// <returns>
        /// the list of children under the given object ID
        /// </returns>
        public IQuery<ODataFeed<Item>> GetChildren(Uri url, bool includeDeleted = false)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<ODataFeed<Item>>(Client);
		    sfApiQuery.Action("Children");
            sfApiQuery.Uri(url);
            sfApiQuery.QueryString("includeDeleted", includeDeleted);
            sfApiQuery.HttpMethod = "GET";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Get Folder Access Info
        /// </summary>
        /// <remarks>
        /// Returns the effective Access Controls for the current authenticated user for the
        /// selected folder - i.e., the resulting set of Access Controls for the Item/User context.This operation applies to Folders only, will return an error for other Item types.
        /// </remarks>
        /// <param name="url"></param>
        /// <returns>
        /// The Folder Access Control Information
        /// </returns>
        public IQuery<ItemInfo> GetInfo(Uri url)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<ItemInfo>(Client);
		    sfApiQuery.Action("Info");
            sfApiQuery.Uri(url);
            sfApiQuery.HttpMethod = "GET";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Download Item Content
        /// </summary>
        /// <remarks>
        /// Initiate the download operation for an item. It will return 302 redirection to the
        /// actual download link. For Folders, the download link will retrieve a ZIP archive
        /// with the contents of the Folder.
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="redirect"></param>
        /// <returns>
        /// the download link for the provided item content.
        /// </returns>
        public IQuery<Stream> Download(Uri url, bool redirect = true)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Stream>(Client);
		    sfApiQuery.Action("Download");
            sfApiQuery.Uri(url);
            sfApiQuery.QueryString("redirect", redirect);
            sfApiQuery.HttpMethod = "GET";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Download Multiple Items
        /// </summary>
        /// <example>
        /// ["id1","id2",...]
        /// </example>
        /// <remarks>
        /// Initiate the download operation for items. It will return 302 redirection to the
        /// actual download link.
        /// </remarks>
        /// <param name="parentUrl"></param>
        /// <param name="ids"></param>
        /// <param name="redirect"></param>
        /// <returns>
        /// the download link for the provided item content.
        /// </returns>
        public IQuery<Stream> BulkDownload(Uri parentUrl, IEnumerable<string> ids, bool redirect = true)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Stream>(Client);
		    sfApiQuery.Action("BulkDownload");
            sfApiQuery.Uri(parentUrl);
            sfApiQuery.QueryString("redirect", redirect);
            sfApiQuery.Body = ids;
            sfApiQuery.HttpMethod = "POST";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Create Folder
        /// </summary>
        /// <example>
        /// {
        /// "Name":"Folder Name",
        /// "Description":"Description",
        /// "Zone":{ "Id":"z014766e-8e96-4615-86aa-57132a69843c" }
        /// }
        /// </example>
        /// <remarks>
        /// Creates a new Folder.
        /// The POST body must contain the serialized object.
        /// For top-level folders, use Items/Folder.
        /// The Zone object may only be provided for top-level folders. The Zone object must
        /// contain a zone ID.
        /// </remarks>
        /// <param name="parentUrl"></param>
        /// <param name="folder"></param>
        /// <param name="overwrite"></param>
        /// <param name="passthrough"></param>
        /// <returns>
        /// the new Folder
        /// </returns>
        public IQuery<Folder> CreateFolder(Uri parentUrl, Folder folder, bool overwrite = false, bool passthrough = false)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Folder>(Client);
		    sfApiQuery.Action("Folder");
            sfApiQuery.Uri(parentUrl);
            sfApiQuery.QueryString("overwrite", overwrite);
            sfApiQuery.QueryString("passthrough", passthrough);
            sfApiQuery.Body = folder;
            sfApiQuery.HttpMethod = "POST";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Create Note
        /// </summary>
        /// <example>
        /// {
        /// "Name":"Note Name",
        /// "Description":"Description"
        /// }
        /// </example>
        /// <remarks>
        /// Creates a new Note.
        /// </remarks>
        /// <param name="parentUrl"></param>
        /// <param name="note"></param>
        /// <returns>
        /// the new Note
        /// </returns>
        public IQuery<Note> CreateNote(Uri parentUrl, Note note)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Note>(Client);
		    sfApiQuery.Action("Note");
            sfApiQuery.Uri(parentUrl);
            sfApiQuery.Body = note;
            sfApiQuery.HttpMethod = "POST";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Create Link
        /// </summary>
        /// <example>
        /// {
        /// "Name":"Link Name",
        /// "Description":"Description",
        /// "Uri":"https://server/path"
        /// }
        /// </example>
        /// <remarks>
        /// Creates a new Link
        /// </remarks>
        /// <param name="parentUrl"></param>
        /// <param name="link"></param>
        /// <returns>
        /// the new Link
        /// </returns>
        public IQuery<Link> CreateLink(Uri parentUrl, Link link)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Link>(Client);
		    sfApiQuery.Action("Link");
            sfApiQuery.Uri(parentUrl);
            sfApiQuery.Body = link;
            sfApiQuery.HttpMethod = "POST";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Create SymbolicLink
        /// </summary>
        /// <example>
        /// {
        /// "Name":"RemoteFileName",
        /// "Description":"Description",
        /// "Zone":{ "Id":"z014766e-8e96-4615-86aa-57132a69843c" },
        /// "ConnectorGroup": { "Id":"1" }
        /// }
        /// </example>
        /// <remarks>
        /// Creates a Symbolic Link
        /// The body must contain either a "Link" parameter with a fully qualified URI; or use
        /// FileName + Zone to have sharefile.com attempt to convert the Connector path to an
        /// URI using a call to the Zone - using ShareFile Hash authentication mode. For active
        /// clients, it's recommended to make the convertion call to the Zone directly, using
        /// Items/ByPath=name, retriving the resulting URL, and calling this method with the
        /// Link parameter.SymbolicLinks must be created as top-level folders - i.e., this call requires
        /// the parent to be the Item(accountid) element.Zone defines the location of the SymbolicLink target - for example, for
        /// Network Shares connectors, the SymbolicLink will point to the StorageZone Controller
        /// that will serve the file browsing requests.The ConnectorGroup parameter indicates the kind of symbolic link - e.g., Network
        /// Share, or SharePoint.
        /// </remarks>
        /// <param name="parentUrl"></param>
        /// <param name="symlink"></param>
        /// <param name="overwrite"></param>
        /// <returns>
        /// the new SymbolicLink
        /// </returns>
        public IQuery<SymbolicLink> CreateSymbolicLink(Uri parentUrl, SymbolicLink symlink, bool overwrite = false)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<SymbolicLink>(Client);
		    sfApiQuery.Action("SymbolicLink");
            sfApiQuery.Uri(parentUrl);
            sfApiQuery.QueryString("overwrite", overwrite);
            sfApiQuery.Body = symlink;
            sfApiQuery.HttpMethod = "POST";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Creates SymbolicLink
        /// </summary>
        /// <example>
        /// {
        /// "Name":"RemoteFileName",
        /// "Description":"Description",
        /// "Link":"https://server/provider/version/Items(id)",
        /// "Zone":{ "Id":"z014766e-8e96-4615-86aa-57132a69843c" },
        /// "ConnectorGroup": { "Id":"1" }
        /// }
        /// </example>
        /// <param name="url"></param>
        /// <param name="symlink"></param>
        /// <param name="overwrite"></param>
        /// <returns>
        /// the new SymbolicLink
        /// </returns>
        public IQuery<SymbolicLink> CreateChildrenByConnectorGroup(Uri url, SymbolicLink symlink, bool overwrite = false)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<SymbolicLink>(Client);
		    sfApiQuery.Action("Children");
            sfApiQuery.Uri(url);
            sfApiQuery.QueryString("overwrite", overwrite);
            sfApiQuery.Body = symlink;
            sfApiQuery.HttpMethod = "POST";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Update Item
        /// </summary>
        /// <example>
        /// {
        /// "Name":"Name",
        /// "FileName":"FileName",
        /// "Description":"Description",
        /// "ExpirationDate": "date",
        /// "Parent": { "Id": "parentid" },
        /// "Zone": { "Id": "zoneid" }
        /// }
        /// </example>
        /// <remarks>
        /// Updates an Item object. Please note that for a Folder, the Name and FileName properties must be consistent.
        /// If a new Name is provided, the FileName will also be updated with the new name, and viceversa.
        /// If both Name and FileName are provided, FileName is disregarded and Name will be used to update both properties.
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="item"></param>
        /// <param name="forceSync"></param>
        /// <returns>
        /// A modified Item object. If the item Zone or Parent Zone is modified, then this
        /// method will return an Asynchronous operation record instead. Note: the parameters listed in the
        /// body of the request are the only parameters that can be updated through this call.
        /// </returns>
        public IQuery<Item> Update(Uri url, Item item, string batchid = null, long batchSizeInBytes = 0, bool forceSync = false, bool scheduleAsync = true, bool resolveFolderNameConflict = false)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Item>(Client);
            sfApiQuery.Uri(url);
            sfApiQuery.QueryString("batchid", batchid);
            sfApiQuery.QueryString("batchSizeInBytes", batchSizeInBytes);
            sfApiQuery.QueryString("forceSync", forceSync);
            sfApiQuery.QueryString("scheduleAsync", scheduleAsync);
            sfApiQuery.QueryString("resolveFolderNameConflict", resolveFolderNameConflict);
            sfApiQuery.Body = item;
            sfApiQuery.HttpMethod = "PATCH";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Update Link
        /// </summary>
        /// <example>
        /// {
        /// "Name":"Name",
        /// "Uri":"https://server/path",
        /// "Description":"Description",
        /// "Parent": { "Id": "parentid" },
        /// }
        /// </example>
        /// <remarks>
        /// Updates a Link object
        /// </remarks>
        /// <param name="id"></param>
        /// <param name="link"></param>
        /// <param name="notify"></param>
        /// <returns>
        /// A modified Link object
        /// </returns>
        public IQuery<Link> UpdateLink(string id, Link link, bool notify = false)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Link>(Client);
		    sfApiQuery.From("Items");
		    sfApiQuery.Action("Link");
            sfApiQuery.ActionIds(id);
            sfApiQuery.QueryString("notify", notify);
            sfApiQuery.Body = link;
            sfApiQuery.HttpMethod = "PATCH";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Update Note
        /// </summary>
        /// <example>
        /// {
        /// "Name":"Name",
        /// "Description":"Description",
        /// "Parent": { "Id": "parentid" },
        /// }
        /// </example>
        /// <remarks>
        /// Updates a Note object
        /// </remarks>
        /// <param name="id"></param>
        /// <param name="note"></param>
        /// <param name="notify"></param>
        /// <returns>
        /// The modified Note object
        /// </returns>
        public IQuery<Note> UpdateNote(string id, Note note, bool notify = false)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Note>(Client);
		    sfApiQuery.From("Items");
		    sfApiQuery.Action("Note");
            sfApiQuery.ActionIds(id);
            sfApiQuery.QueryString("notify", notify);
            sfApiQuery.Body = note;
            sfApiQuery.HttpMethod = "PATCH";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Update SymbolicLink
        /// </summary>
        /// <example>
        /// {
        /// "Name":"Name",
        /// "Description":"Description",
        /// "Link": "https://server/path"
        /// }
        /// </example>
        /// <remarks>
        /// Updates a Symbolic Link object
        /// </remarks>
        /// <param name="id"></param>
        /// <param name="symlink"></param>
        /// <returns>
        /// The modified SymbolicLink object
        /// </returns>
        public IQuery<SymbolicLink> UpdateSymbolicLink(string id, SymbolicLink symlink)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<SymbolicLink>(Client);
		    sfApiQuery.From("Items");
		    sfApiQuery.Action("SymbolicLink");
            sfApiQuery.ActionIds(id);
            sfApiQuery.Body = symlink;
            sfApiQuery.HttpMethod = "PATCH";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Delete Item
        /// </summary>
        /// <remarks>
        /// Removes an item
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="singleversion"></param>
        /// <param name="forceSync"></param>
        public IQuery Delete(Uri url, bool singleversion = false, bool forceSync = false)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query(Client);
            sfApiQuery.Uri(url);
            sfApiQuery.QueryString("singleversion", singleversion);
            sfApiQuery.QueryString("forceSync", forceSync);
            sfApiQuery.HttpMethod = "DELETE";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Delete Multiple Items
        /// </summary>
        /// <example>
        /// ["id1","id2",...]
        /// </example>
        /// <remarks>
        /// All items in bulk delete must be children of the same parent, identified in the URI
        /// </remarks>
        /// <param name="id"></param>
        /// <param name="body"></param>
        /// <param name="forceSync"></param>
        /// <param name="deletePermanently"></param>
        public IQuery BulkDelete(Uri url, IEnumerable<string> ids, bool forceSync = false, bool deletePermanently = false)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query(Client);
		    sfApiQuery.Action("BulkDelete");
            sfApiQuery.Uri(url);
            sfApiQuery.QueryString("forceSync", forceSync);
            sfApiQuery.QueryString("deletePermanently", deletePermanently);
            sfApiQuery.Body = ids;
            sfApiQuery.HttpMethod = "POST";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Get Thumbnail
        /// </summary>
        /// <remarks>
        /// Retrieve a thumbnail link from the specified Item.
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="size"></param>
        /// <param name="redirect"></param>
        /// <returns>
        /// A 302 redirection to the Thumbnail link
        /// </returns>
        public IQuery<Stream> GetThumbnail(Uri url, int size = 75, bool redirect = false)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Stream>(Client);
		    sfApiQuery.Action("Thumbnail");
            sfApiQuery.Uri(url);
            sfApiQuery.QueryString("size", size);
            sfApiQuery.QueryString("redirect", redirect);
            sfApiQuery.HttpMethod = "GET";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Get Breadcrumbs
        /// </summary>
        /// <remarks>
        /// Retrieves the path from an item from the root. The return list is a Feed of Items, with the top-level
        /// folder at the first position. If this item is in a Connection path, the breadcrumbs may contain URL
        /// reference back to the parent account - and the Item in the feed will contain just the URL reference.
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="path"></param>
        /// <returns>
        /// A feed containing the path of folders from the specified root to the item, in order
        /// </returns>
        public IQuery<ODataFeed<Item>> GetBreadcrumbs(Uri url, string path = null)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<ODataFeed<Item>>(Client);
		    sfApiQuery.Action("Breadcrumbs");
            sfApiQuery.Uri(url);
            sfApiQuery.QueryString("path", path);
            sfApiQuery.HttpMethod = "GET";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Copy Item
        /// </summary>
        /// <remarks>
        /// Copies an item to a new target Folder. If the target folder is in another zone, the operation will
        /// return an AsyncOperation record instead. Clients may query the /AsyncOperation Entity to determine
        /// operation progress and result.
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="targetid"></param>
        /// <param name="overwrite"></param>
        /// <returns>
        /// the modified source object
        /// </returns>
        public IQuery<Item> Copy(Uri url, string targetid, bool overwrite = false)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Item>(Client);
		    sfApiQuery.Action("Copy");
            sfApiQuery.Uri(url);
            sfApiQuery.QueryString("targetid", targetid);
            sfApiQuery.QueryString("overwrite", overwrite);
            sfApiQuery.HttpMethod = "POST";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Upload File
        /// </summary>
        /// <example>
        /// POST https://account.sf-api.com/sf/v3/Items(id)/Upload2
        /// {
        /// "Method":"Method",
        /// "Raw": false,
        /// "FileName":"FileName"
        /// "FileLength": length
        /// }
        /// </example>
        /// <remarks>
        /// Prepares the links for uploading files to the target Folder.
        /// This method returns an Upload Specification object. The fields are
        /// populated based on the upload method, provider, and resume parameters passed to the
        /// upload call.
        /// The Method determines how the URLs must be called.
        /// 
        /// There are two different URL's to upload: /sf/v3/Items(id)/Upload? accepts the upload parameters
        /// through a query URL string, while /sf/v3/Items(id)/Upload2 does it through the HTTP POST message body.
        /// If using 'Upload2', the parameters must be capitalized.
        /// 
        /// Standard uploads use a single HTTP POST message to the ChunkUri address provided in
        /// the response. All other fields will be empty. Standard uploads do not support Resume.
        /// 
        /// Streamed uploads use multiple HTTP POST calls to the ChunkUri address. The client must
        /// append the parameters index, offset and hash to the end of the ChunkUri address. Index
        /// is a sequential number representing the data block (zero-based); Offset represents the
        /// byte offset for the block; and hash contains the MD5 hash of the block. The last HTTP
        /// POST must also contain finish=true parameter.
        /// 
        /// Threaded uploads use multiple HTTP POST calls to ChunkUri, and can have a number of
        /// threads issuing blocks in parallel. Clients must append index, offset and hash to
        /// the end of ChunkUri, as explained in Streamed. After all chunks were sent, the client
        /// must call the FinishUri provided in this spec.
        /// 
        /// If using the Threaded Uploader, you can attach the argument fmt=json to each ChunkUri
        /// to indicate you wish to retrieve the Item ID of the file after the upload is completed.
        /// 
        /// For all uploaders, the contents of the POST Body can either be "raw", if the "Raw" parameter
        /// was provided to the Uploader, or use MIME multi-part form encoding otherwise. Raw uploads
        /// simply put the block content in the POST body - Content-Length specifies the size. Multi-part
        /// form encoding has to pass the File as a Form parameter named "File1".
        /// 
        /// For streamed and threaded, if Resume options were provided to the Upload call, then the
        /// fields IsResume, ResumeIndex, ResumeOffset and ResumeFileHash MAY be populated. If they are,
        /// it indicates that the server has identified a partial upload with that specification, and is
        /// ready to resume on the provided parameters. The clients can then verify the ResumeFileHash to
        /// ensure the file has not been modified; and continue issuing ChunkUri calls from the ResumeIndex
        /// ResumeOffset parameters. If the client decides to restart, it should simply ignore the resume
        /// parameters and send the blocks from Index 0.
        /// 
        /// For all uploaders: the result code for the HTTP POST calls to Chunk and Finish Uri can either
        /// be a 401 - indicating authentication is required; 4xx/5xx indicating some kind of error; or
        /// 200 with a Content Body of format 'ERROR:message'. Successful calls will return either a 200
        /// response with no Body, or with Body of format 'OK'.
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="method"></param>
        /// <param name="raw"></param>
        /// <param name="fileName"></param>
        /// <param name="fileSize"></param>
        /// <param name="batchId"></param>
        /// <param name="batchLast"></param>
        /// <param name="canResume"></param>
        /// <param name="startOver"></param>
        /// <param name="unzip"></param>
        /// <param name="tool"></param>
        /// <param name="overwrite"></param>
        /// <param name="title"></param>
        /// <param name="details"></param>
        /// <param name="isSend"></param>
        /// <param name="sendGuid"></param>
        /// <param name="opid"></param>
        /// <param name="threadCount"></param>
        /// <param name="responseFormat"></param>
        /// <param name="notify"></param>
        /// <param name="clientCreatedDateUTC"></param>
        /// <param name="clientModifiedDateUTC"></param>
        /// <returns>
        /// an Upload Specification element, containing the links for uploading, and the parameters for resume.
        /// The caller must know the protocol for sending the prepare, chunk and finish URLs returned in the spec; as well as
        /// negotiate the resume upload.
        /// </returns>
        public IQuery<UploadSpecification> Upload(Uri url, UploadMethod method = UploadMethod.Standard, bool raw = false, string fileName = null, long fileSize = 0, string batchId = null, bool batchLast = false, bool canResume = false, bool startOver = false, bool unzip = false, string tool = "apiv3", bool overwrite = false, string title = null, string details = null, bool isSend = false, string sendGuid = null, string opid = null, int threadCount = 4, string responseFormat = "json", bool notify = false, DateTime? clientCreatedDateUTC = null, DateTime? clientModifiedDateUTC = null, int? expirationDays = null)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<UploadSpecification>(Client);
		    sfApiQuery.Action("Upload");
            sfApiQuery.Uri(url);
            sfApiQuery.QueryString("method", method);
            sfApiQuery.QueryString("raw", raw);
            sfApiQuery.QueryString("fileName", fileName);
            sfApiQuery.QueryString("fileSize", fileSize);
            sfApiQuery.QueryString("batchId", batchId);
            sfApiQuery.QueryString("batchLast", batchLast);
            sfApiQuery.QueryString("canResume", canResume);
            sfApiQuery.QueryString("startOver", startOver);
            sfApiQuery.QueryString("unzip", unzip);
            sfApiQuery.QueryString("tool", tool);
            sfApiQuery.QueryString("overwrite", overwrite);
            sfApiQuery.QueryString("title", title);
            sfApiQuery.QueryString("details", details);
            sfApiQuery.QueryString("isSend", isSend);
            sfApiQuery.QueryString("sendGuid", sendGuid);
            sfApiQuery.QueryString("opid", opid);
            sfApiQuery.QueryString("threadCount", threadCount);
            sfApiQuery.QueryString("responseFormat", responseFormat);
            sfApiQuery.QueryString("notify", notify);
            sfApiQuery.QueryString("clientCreatedDateUTC", clientCreatedDateUTC);
            sfApiQuery.QueryString("clientModifiedDateUTC", clientModifiedDateUTC);
            sfApiQuery.QueryString("expirationDays", expirationDays);
            sfApiQuery.HttpMethod = "POST";	
		    return sfApiQuery;
        }
        public IQuery<UploadSpecification> Upload2(Uri url, UploadRequestParams uploadParams, int? expirationDays = null)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<UploadSpecification>(Client);
		    sfApiQuery.Action("Upload2");
            sfApiQuery.Uri(url);
            sfApiQuery.QueryString("expirationDays", expirationDays);
            sfApiQuery.Body = uploadParams;
            sfApiQuery.HttpMethod = "POST";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Unlock File
        /// </summary>
        /// <remarks>
        /// Unlock a locked file.
        /// This operation is only implemented in Sharepoint providers (/sp)
        /// </remarks>
        /// <param name="url"></param>
        /// <param name="message"></param>
        public IQuery CheckIn(Uri url, string message = null)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query(Client);
		    sfApiQuery.Action("CheckIn");
            sfApiQuery.Uri(url);
            sfApiQuery.QueryString("message", message);
            sfApiQuery.HttpMethod = "POST";	
		    return sfApiQuery;
        }
        public IQuery CheckOut(Uri url)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query(Client);
		    sfApiQuery.Action("CheckOut");
            sfApiQuery.Uri(url);
            sfApiQuery.HttpMethod = "POST";	
		    return sfApiQuery;
        }
        public IQuery DiscardCheckOut(Uri url)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query(Client);
		    sfApiQuery.Action("DiscardCheckOut");
            sfApiQuery.Uri(url);
            sfApiQuery.HttpMethod = "POST";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Search
        /// </summary>
        /// <remarks>
        /// Search for Items matching the criteria of the query parameter
        /// </remarks>
        /// <param name="query"></param>
        /// <param name="maxResults"></param>
        /// <param name="skip"></param>
        /// <param name="homeFolderOnly"></param>
        /// <returns>
        /// SearchResults
        /// </returns>
        public IQuery<SearchResults> Search(string query, int maxResults = 50, int skip = 0, bool homeFolderOnly = false)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<SearchResults>(Client);
		    sfApiQuery.From("Items");
		    sfApiQuery.Action("Search");
            sfApiQuery.QueryString("query", query);
            sfApiQuery.QueryString("maxResults", maxResults);
            sfApiQuery.QueryString("skip", skip);
            sfApiQuery.QueryString("homeFolderOnly", homeFolderOnly);
            sfApiQuery.HttpMethod = "GET";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Advanced Simple Search
        /// </summary>
        /// <example>
        /// {
        /// "Query":{
        /// "ItemType":"",
        /// "ParentID":"",
        /// "CreatorID":"",
        /// "SearchQuery":"",
        /// "CreateStartDate":"",
        /// "CreateEndDate":"",
        /// "ItemNameOnly":false
        /// },
        /// "Paging":{
        /// "PageNumber":1, (Deprecated)
        /// "PageSize":10, (Deprecated)
        /// "Count": 50
        /// "Skip": 0
        /// },
        /// "Sort":{
        /// "SortBy":"",
        /// "Ascending":false,
        /// },
        /// "TimeoutInSeconds":10
        /// }
        /// </example>
        /// <remarks>
        /// Search for Items matching the criteria of the query parameter
        /// </remarks>
        /// <param name="simpleSearchQuery"></param>
        /// <returns>
        /// AdvancedSearchResults
        /// </returns>
        public IQuery<AdvancedSearchResults> AdvancedSimpleSearch(SimpleSearchQuery simpleSearchQuery)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<AdvancedSearchResults>(Client);
		    sfApiQuery.From("Items");
		    sfApiQuery.Action("AdvancedSimpleSearch");
            sfApiQuery.Body = simpleSearchQuery;
            sfApiQuery.HttpMethod = "POST";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Advanced Search
        /// </summary>
        /// <example>
        /// {
        /// "Query":{
        /// "ItemTypes":["type1", "type2", ...],
        /// "ParentID":["id1", "id2", ...],
        /// "CreatorID":["id1", "id2", ...],
        /// "SearchQuery":"",
        /// "CreateStartDate":"",
        /// "CreateEndDate":"",
        /// "ItemNameOnly":false
        /// },
        /// "Paging":{
        /// "PageNumber":1, (deprecated)
        /// "PageSize":10, (deprecated)
        /// "Count":50, (default value)
        /// "Skip":0, (default value)
        /// },
        /// "Sort":{
        /// "SortBy":"",
        /// "Ascending":false,
        /// },
        /// "TimeoutInSeconds":10
        /// }
        /// </example>
        /// <remarks>
        /// Search for Items matching the criteria of the query parameter
        /// </remarks>
        /// <param name="searchQuery"></param>
        /// <returns>
        /// AdvancedSearchResults
        /// </returns>
        public IQuery<AdvancedSearchResults> AdvancedSearch(SearchQuery searchQuery)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<AdvancedSearchResults>(Client);
		    sfApiQuery.From("Items");
		    sfApiQuery.Action("AdvancedSearch");
            sfApiQuery.Body = searchQuery;
            sfApiQuery.HttpMethod = "POST";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Get Web Preview Link
        /// </summary>
        /// <remarks>
        /// Redirects the caller to the Web Edit application for the selected item.
        /// </remarks>
        /// <param name="url"></param>
        /// <returns>
        /// A redirection message to the Web Edit app for this item. It returns 404 (Not Found)
        /// if the Web Preview app doesn't support the file type.
        /// </returns>
        public IQuery<Redirection> WebView(Uri url)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Redirection>(Client);
		    sfApiQuery.Action("WebView");
            sfApiQuery.Uri(url);
            sfApiQuery.HttpMethod = "GET";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Get List of Item Protocol Links
        /// </summary>
        /// <param name="url"></param>
        /// <param name="platform"></param>
        /// <returns>
        /// A list of protocol links depending on the input parameter 'platform', 404 (Not Found) if not supported by the item
        /// </returns>
        public IQuery<ODataFeed<ItemProtocolLink>> GetProtocolLinks(Uri url, PreviewPlatform platform)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<ODataFeed<ItemProtocolLink>>(Client);
		    sfApiQuery.Action("ProtocolLinks");
            sfApiQuery.Uri(url);
            sfApiQuery.ActionIds(platform);
            sfApiQuery.HttpMethod = "GET";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Get Redirection endpoint Information
        /// </summary>
        /// <remarks>
        /// Returns the redirection endpoint for this Item.This operation applies to Folders and SymbolicLinks only, will return an error for other Item types.
        /// </remarks>
        /// <param name="url"></param>
        /// <returns>
        /// The Redirection endpoint Information
        /// </returns>
        public IQuery<Redirection> GetRedirection(Uri url)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<Redirection>(Client);
		    sfApiQuery.Action("Redirection");
            sfApiQuery.Uri(url);
            sfApiQuery.HttpMethod = "GET";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Get a collection of recoverable/deleted items in a folder
        /// </summary>
        /// <param name="url"></param>
        public IQuery<ODataFeed<Item>> GetDeletedChildren(Uri url, string id)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<ODataFeed<Item>>(Client);
		    sfApiQuery.Action("DeletedChildren");
            sfApiQuery.Uri(url);
            sfApiQuery.QueryString("parentid", id);
            sfApiQuery.HttpMethod = "GET";	
		    return sfApiQuery;
        }
        public IQuery<ODataFeed<Item>> GetUserDeletedItems(string userid = null, string zone = null)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query<ODataFeed<Item>>(Client);
		    sfApiQuery.From("Items");
		    sfApiQuery.Action("UserDeletedItems");
            sfApiQuery.QueryString("userid", userid);
            sfApiQuery.QueryString("zone", zone);
            sfApiQuery.HttpMethod = "GET";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Restore expired items to their original locations
        /// </summary>
        /// <param name="ids"></param>
        public IQuery BulkRestore(IEnumerable<string> ids)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query(Client);
		    sfApiQuery.From("Items");
		    sfApiQuery.Action("BulkRestore");
            sfApiQuery.Body = ids;
            sfApiQuery.HttpMethod = "POST";	
		    return sfApiQuery;
        }
        
        /// <summary>
        /// Permanently delete multiple items
        /// </summary>
        /// <param name="itemIds"></param>
        /// <param name="ids"></param>
        public IQuery BulkDeletePermanently(IEnumerable<string> ids)
        {
            var sfApiQuery = new ShareFile.Api.Client.Requests.Query(Client);
		    sfApiQuery.From("Items");
		    sfApiQuery.Action("BulkDeletePermanently");
            sfApiQuery.Body = ids;
            sfApiQuery.HttpMethod = "POST";	
		    return sfApiQuery;
        }
    }
}